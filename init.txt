# Crawl Init file
# See the README for further details:
# https://github.com/gammafunk/dcss-rc/blob/master/README.md

# NOTE: This RC has things enabled only for my username. If you're just
# including this RC file in your own with
#
# include = gammafunk.rc
#
# then you don't have to worry about these. However if you're copy all or parts
# of gammafunk.rc directly into your own RC file, look for any sections
# conditioned on my username and follow notes in the comments for removing or
# modifying them.


###############
### Display ###
###############

#"black", "blue", "green", "cyan", "red", "magenta", "brown",
#  "lightgrey", "darkgrey", "lightblue", "lightgreen", "lightcyan",
#  "lightred", "lightmagenta", "yellow", "white"
# black
# blue - Dangerous
# green - Generally good
# cyan - Conditional
# red - Extremely bad
# magenta - magic bias?
# brown
# lightgrey - Default
# darkgrey - worthless
# lightblue
# lightgreen
# lightcyan
# lightred - very good
# lightmagenta
# yellow
# white - Epic level.


view_delay = 300
hp_colour = 100:green, 99:lightgray, 75:yellow, 50:lightred, 25:red
mp_colour = 100:green, 99:lightgray, 75:yellow, 50:lightred, 25:red
hp_warning = 50
mp_warning = 50

# enemy_hp_colour = green green brown brown red magenta

#enemy_hp_colour = green lightgreen yellow lightred red magenta
#monster_list_colour =
#monster_list_colour += friendly:green,neutral:brown
#monster_list_colour += good_neutral:brown,strict_neutral:brown
#monster_list_colour += trivial:darkgrey,easy:lightgrey
#monster_list_colour += tough:yellow,nasty:lightred

###############
### Console ###
###############

# Enable use of darkgrey.
bold_brightens_foreground=true

# Monster List
mlist_allow_alternate_layout = true
monster_item_view_coordinates = true

equip_bar = true

## For item_glyph, subsequent matches override previous ones.
item := item_glyph

## Reasonable defaults
item += potion:lightgrey
item += scroll:lightgrey
item += wand:lightgrey
item += dangerous_item:blue
item += useless_item:darkgrey

### Potions ###

item += potions? of.*berserk:brown
item += potions? of.*mutation:lightcyan

item += potions? of.*(lignification|ambrosia):blue
item += potions? of.*haste:green
item += potions? of.*might:yellow
item += potions? of.*resistance:lightgreen

item += potions? of.*heal wounds:white
item += potions? of.*curing:lightblue
item += potions? of.*cancellation:cyan

item += potions? of.*brilliance:magenta
item += potions? of.*magic:lightmagenta

item += potions? of.*experience:lightred


item += potions? of.*(flight|invisibility|attraction):lightgreen


### Scrolls ###

: if you.race() == "Vampire" or you.race() == "Mummy"
:  or you.race() == "Ghoul" then
  item += scroll.*torment:brown
: else
  item += scroll.*torment:darkgrey
: end

item += scroll.*poison:brown

item += scroll.*acquirement:lightred
item += scroll.*(summoning):yellow
item += scroll.*identify:white
item += scroll.*magic mapping:lightcyan

item += scroll.*(silence|vulnerability|immolation):blue
item += scroll.*(fog|butterflies|teleport):green
item += scroll.*(fear|blink):lightgreen
item += scroll.*(enchant|brand weapon):lightmagenta

### Wands ###

# Single target piercing.
item += wand of.*(acid|light|quicksilver):yellow

item += wand of.*flame:lightgrey

item += wand of.*digging:green

# Single-turn AOE
item += wand of.*(iceblast|roots):cyan

# MR-checking
item += wand of.*(mindburst|polymorph):magenta
item += wand of.*(paralysis|charming):lightmagenta

### General Identification ###
item += manual of:cyan
item += manual:lightcyan
item += unidentified.*book:lightmagenta
item += unidentified.*(potion|scroll|jewellery|wand|magical staff).*:lightblue

item += (identified|known).*(jewellery|magical staff):brown
item += identified.*spellbook:magenta

### Jewellery ###
item += .*ring of (dexterity|strength|intelligence):lightcyan
item += .*ring of (evasion|protection|slaying):lightmagenta
item += .*ring of (protection from|resist corrosion|poison resistance|positive energy|willpower):green
item += .*ring of (wizardry|magical power):magenta
item += .*ring of (fire|ice):cyan

item += .*amulet of (the acrobat|guardian spirit|reflection):lightgreen
item += .*amulet of.*regeneration:lightred
item += .*amulet of faith:cyan

item += identified.*artefact.*(jewellery):white
item += unidentified.*artefact.*(jewellery).*:lightmagenta


# Want this to override anything above
item += useless:darkgrey
# Only mark these types when forbidden; for other types it looks odd.
item += forbidden.*(potion|scroll):red

mons := mon_glyph
# Monsters that can be easy to miss
mons ^= * : ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚ÂœÃƒÂ‚Ã‚Â±
mons ^= dancing weapon : cyan {
mons ^= spectral weapon : lightcyan {
# Classed Demonspawn
mon += blood saint:9
mon += warmonger:9
mon += corrupter:9
mon += black sun:9

# Wall glyphs; requires a font and terminal that can render these.
feature += crystal wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Â‘}
feature += stone wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Â’}
feature += metal wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Â“}
feature += unnaturally hard rock wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Âˆ}

feature += altar {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚ÂšÃƒÂ‚Ã‚Â‘}

#############
### Tiles ###
#############

tile_window_width = 1300
tile_window_height = 700
tile_full_screen = false
tile_map_pixels = 3


###################
### Menu Colors ###
###################

# These should match the item_glyph colours exactly when possible.
# For menu_colour, the first match ignores subsequent matches.
menu := menu_colour
menu =

# Many of the entries below come from dat/defaults/menu_colours.txt,
# which we have to duplicate here since we want only some of the
# entries from that file.
menu += notes:white:Reached XP level

### General Inventory###
# Items currently not affecting you.
menu += darkgrey:(melded)
# Items disliked by your god.
menu += red:forbidden
# Useless items, comes here to override artefacts etc.
menu += darkgrey:.*useless.*
# Handle cursed and equipped items early to override other colour settings.
menu += lightred:.*equipped.* cursed
menu += red: (a|the) cursed
menu += inventory:lightgreen:.*equipped.*
# Colouring of autoinscribed god gifts
menu += pickup:lightred:god gift
# Highlight (partly) selected items
menu += inventory:white:\w \+\s
menu += inventory:white:\w \#\s

### Potions ###


menu += brown:potions? of.*berserk
menu += lightcyan:potions? of.*mutation

menu += blue:potions? of.*(lignification|ambrosia)
menu += green:potions? of.*haste
menu += yellow:potions? of.*might
menu += lightgreen:potions? of.*resistance

menu += white:potions? of.*heal wounds
menu += lightblue:potions? of.*curing
menu += cyan:potions? of.*cancellation

menu += magenta:potions? of.*brilliance
menu += lightmagenta:potions? of.*magic

menu += lightred:potions? of.*experience

### Scrolls ###

: if you.race() == "Vampire" or you.race() == "Mummy"
:  or you.race() == "Ghoul" then
  menu += brown:scroll.*torment
: else
  menu += darkgrey:scroll.*torment
: end
menu += brown:scroll.*poison

menu += lightred:scroll.*acquirement
menu += yellow:scroll.*(summoning)
menu += white:scroll.*identify
menu += lightcyan:scroll.*magic mapping

menu += blue:scroll.*(silence|vulnerability|immolation)
menu += green:scroll.*(fog|butterflies|teleport)
menu += lightgreen:scroll.*(fear|blink)
menu += lightmagenta:scroll.*(enchant|brand weapon)

### Wands ###

# Single target piercing.
menu += yellow:wand of.*(acid|light|quicksilver)

menu += lightgrey:wand of.*flame

menu += green:wand of.*digging

# Explosion
menu += cyan:wand of.*(iceblast|roots)

# MR-checking
menu += magenta:wand of.*(mindburst|polymorph)
menu += lightmagenta:wand of.*(paralysis|charming)

### General identification ###

menu += cyan:manual of
menu += lightcyan:manual
menu += lightmagenta:unidentified.*artefact.*
menu += white:.*artefact.*
menu += lightblue:unidentified .*(potion|scroll|wand|jewellery|spellbook|rod|magical staff)

menu += inventory:lightgray:.*(book|jewellery|magical staff)
# Ego items
menu += lightblue:unidentified.*weapon.*(runed|glowing|enchanted)
menu += lightblue:unidentified.*armour.*(runed|glowing|embroidered|shiny|dyed)

### Jewllery ###


menu += magenta:


menu += lightcyan:.*ring of (dexterity|strength|intelligence)
menu += lightmagenta:.*ring of (evasion|protection|slaying)
menu += green:.*ring of (protection from|resist corrosion|poison resistance|positive energy|willpower)
menu += magenta:.*ring of (wizardry|magical power)
menu += cyan:.*ring of (fire|ice)

menu += lightgreen:.*amulet of (the acrobat|guardian spirit|reflection)
menu += lightred:.*amulet of.*regeneration
menu += cyan:.*amulet of faith

menu += white:identified.*artefact.*(jewellery)
menu += lightmagenta:unidentified.*artefact.*(jewellery).*


#################
### Interface ###
#################

autofight_stop = 65
hp_warning = 20
item_stack_summary_minimum = 8
default_manual_training = true
messages_at_top = true
show_more = false
autofight_caught = true
sort_menus = true:equipped,art,ego,glowing,identified,basename,qualname,>qty
drop_filter += useless_item, forbidden
fire_order = silver javelin, javelin, silver boomerang, boomerang, curare-tipped dart, poisoned dart, stone


default_manual_training = true
equip_unequip = true


# Spam autofight is bad
autofight_warning = 250


delay_safe_poison = 10:5


# No movement on regular tab
bindkey = [^I] CMD_AUTOFIGHT_NOMOVE
# Move as normal on g.
bindkey = [g] CMD_AUTOFIGHT


#runrest_ignore_message ^= You feel.*sick


############################
### Travel & Exploration ###
############################

rest_wait_both = true
rest_wait_ancestor = true
travel_delay = 1
explore_delay = 1
rest_delay = -1

show_travel_trail = true
explore_stop += greedy_items
explore_wall_bias = 4

travel_key_stop = false

explore_auto_rest = true

warn_hatches = true
travel_open_doors = true
# change to avoid if stealth rating above, say, 50.

################
# Keybindings to override the vi movement keys.
# CMD_NO_CMD_DEFAULT results in "Unknown command."
# See docs/keybind.txt for other commands.
################

bindkey = [h] CMD_NO_CMD_DEFAULT
bindkey = [j] CMD_NO_CMD_DEFAULT
bindkey = [k] CMD_NO_CMD_DEFAULT
bindkey = [l] CMD_NO_CMD_DEFAULT
bindkey = [H] CMD_NO_CMD_DEFAULT
bindkey = [J] CMD_NO_CMD_DEFAULT
bindkey = [K] CMD_NO_CMD_DEFAULT
bindkey = [L] CMD_NO_CMD_DEFAULT
#bindkey = [^H] CMD_NO_CMD_DEFAULT
#bindkey = [^J] CMD_NO_CMD_DEFAULT
#bindkey = [^K] CMD_NO_CMD_DEFAULT
#bindkey = [^L] CMD_NO_CMD_DEFAULT
bindkey = [y] CMD_NO_CMD_DEFAULT
bindkey = [u] CMD_NO_CMD_DEFAULT
bindkey = [b] CMD_NO_CMD_DEFAULT
bindkey = [n] CMD_NO_CMD_DEFAULT
bindkey = [Y] CMD_NO_CMD_DEFAULT
bindkey = [U] CMD_NO_CMD_DEFAULT
bindkey = [B] CMD_NO_CMD_DEFAULT
bindkey = [N] CMD_NO_CMD_DEFAULT
#bindkey = [^Y] CMD_NO_CMD_DEFAULT
#bindkey = [^U] CMD_NO_CMD_DEFAULT
#bindkey = [^B] CMD_NO_CMD_DEFAULT
#bindkey = [^N] CMD_NO_CMD_DEFAULT

#################################
####### Main options ############
#################################
autofight_stop = 65
hp_warning = 20
item_stack_summary_minimum = 8
default_manual_training = true
messages_at_top = true
show_more = false
autofight_caught = true
rest_wait_both = true
rest_wait_ancestor = true
sort_menus = true:equipped,art,ego,glowing,identified,basename,qualname,>qty
drop_filter += useless_item, forbidden
fire_order = silver javelin, javelin, silver boomerang, boomerang, curare-tipped dart, poisoned dart, stone



#################################
####### Explore options #########
#################################
explore_delay = -1
travel_delay = -1
rest_delay = -1
view_delay = 500
show_travel_trail = true

explore_greedy_visit = artefacts,glowing_items,stacks
explore_stop = artefacts,altars,branches,portals,runed_doors,greedy_pickup_smart
explore_stop_pickup_ignore += scroll, potion, wand, stone, dart, boomerang, javelin


#######################################
####### Autopickup exceptions #########
#######################################
autopickup_exceptions ^= <potions? of attraction, <potions? of lignification, <potions? of mutation
autopickup_exceptions ^= <scrolls? of immolation, <scrolls? of poison
autopickup_exceptions ^= >useless_item, <misc
# Exclude the 3rd copy of any ring
{
  add_autopickup_func(function (it, name)
    if it.class(true) ~= "jewellery" or it.artefact then return end
    local st = it.subtype()
    local found_first = false
    for inv in iter.invent_iterator:new(items.inventory()) do
      if inv.class(true) == "jewellery" and inv.subtype() == st then
        if found_first then return false end
        found_first = true
      end
    end
  end)
}

##################
### Autopickup ###
##################

# Add staves, rods, misc; note you can't use += with this option.
autopickup = $?!+=/}|

#All useful, at least early game.
#Its only later that you would want to just remove these.
ae := autopickup_exceptions
ae += <throwing net
ae += <javelin
ae += <dart
ae += <stone
ae += <boomerang

: if you.race() == "Troll" or you.race() == ogre then
	ae += <large rock
: end

ae += <curare-tipped dart

ae ^= <spellbook
autopickup_exceptions ^= <tin of tremorstones


# Exceptions
# I use immolation somewhat early on, and vulnerability is useful the entire
# game.
ae += <vulnerability|immolation
# Don't ever need a second stave
ae += staff of .*





##########
# Macros #
##########

bindkey = [~] CMD_LUA_CONSOLE
macros += M [ ===load_char_defaults
macros += M ] ===save_char_defaults
macros += M o ===enhanced_explore

macros += M + .


# Replacing VI keys, so
# yughjkbn are free.
#
# I is blink
# o is self-enhancement
# z is starting blast
# x, s seem to be better attack spells.
# aside from that, hard to say.
# figure it out and setup some defaults.
# keep blink as is, or figure out how to add a confirmation. Or use a capital/Ctrl mod.
# That actually gives me 24 macro slots.
# Make defaults for swapping rings, maybe necklaces.

macros += M z z*
macros += M h Zh
macros += M j Zj
macros += M k Zk
macros += M l Zl
macros += M y Zy
macros += M u Zu
macros += M b Zb
macros += M n Zn


###########################
### Spell/Ability slots ###
###########################

ability_slot += Fly|flight:lF
ability_slot += Stop Flying:L
ability_slot += Breathe:t
ability_slot += Invisibility:iv
# Abilities prone to miskeys.
ability_slot += Blink:IB
ability_slot += Berserk:k
ability_slot += Corrupt:C
ability_slot += Enter the Abyss:E

# 4 letters from words of the spell name at (1) beginning, (2) end,
# of words in the spell, (3) anywhere from the spell name, or (4) from the
# names of the spell schools, in order of preference.

#spell_slot += Alistair's intoxication:aisn
#spell_slot += Apportation:anpt
#spell_slot += Airstrike:ae
#spell_slot += Agony:aygn
#spell_slot += Animate dead:adet
#spell_slot += Animate skeleton:asen
#spell_slot += Beastly appendage:baye
#spell_slot += Blade hands:bhes
#spell_slot += Blink:BKLN
#spell_slot += Bolt of magma:bmta
#spell_slot += Borgnjor's revivification:BRSN
#spell_slot += Borgnjor's vile clutch:bvch
#spell_slot += Call canine familiar:cflr
#spell_slot += Call imp:cilp
#spell_slot += Cause fear:cfer
#spell_slot += Controlled blink:cbdk
#spell_slot += Corona:carn
#spell_slot += Chain lightning:clng
#spell_slot += Confusing touch:ctgh
#spell_slot += Conjure flame:cfej
#spell_slot += Corpse rot:cret
#spell_slot += Dazzling Flash:dfgh
#spell_slot += Darkness:aed
#spell_slot += Death channel:dtcl
## Upper-case to prevent miskeys.
#spell_slot += Death's door:DROT
#spell_slot += Discord:DCSR
#spell_slot += Disjunction:iuoe
#spell_slot += Dispel undead:ndp
#spell_slot += Dispersal:iea
#spell_slot += Dragon form:dgrf
#spell_slot += Dragon's call:dcl
#spell_slot += Ensorcelled hibernation:ehnd
#spell_slot += Eringya's Toxic Bog:bteg
#spell_slot += Excruciating wounds:ewgx
#spell_slot += Fire storm:fsmt
#spell_slot += Fireball:flbr
#spell_slot += Foxfire:fxro
#spell_slot += Freezing cloud:fcgd
#spell_slot += Freeze:fezr
#spell_slot += Frozen Ramparts:frnt
#spell_slot += Fulminant prism:fpmt
#spell_slot += Gell's Gravitas:glvt
#spell_slot += Haunt:htna
#spell_slot += Ice form:crmf
#spell_slot += Ignition:ntg
#spell_slot += Iron shot:stnr
#spell_slot += Inner flame:frn
#spell_slot += Invisibility:iyvb
#spell_slot += Irradiate:ierd
#spell_slot += Iskenderun's battlesphere:ibne
#spell_slot += Leda's Liquefaction:lanq
#spell_slot += Lee's rapid deconstruction:ldr
#spell_slot += Lesser Beckoning:lbg
#spell_slot += Lehudib's crystal spear:lcsb
#spell_slot += Lightning bolt:lbgt
#spell_slot += Magic dart:mdtc
#spell_slot += Malign gateway:mgy
#spell_slot += Manifold Assault:madt
#spell_slot += Maxwell's Capacitive Coupling:mclp
#spell_slot += Mephitic cloud:mcdp
#spell_slot += Metabolic englaciation:mcn
#spell_slot += Monstrous menagerie:mst
#spell_slot += Necromutation:eou
#spell_slot += Olgreb's toxic radiance:oia
#spell_slot += Orb of destruction:dbn
#spell_slot += Ozocubu's armour:oau
#spell_slot += Ozocubu's refrigeration:cbz
#spell_slot += Pain:pnai
#spell_slot += Passage of golubria:uoi
#spell_slot += Passwall:aeu
#spell_slot += Petrify:pyt
#spell_slot += Poisonous vapours:pvs
#spell_slot += Portal projectile:oei
#spell_slot += Sandblast:zst
#spell_slot += Searing ray:sry
#spell_slot += Shadow creatures:scw
## Upper-case to prevent miskeys.
#spell_slot += Shatter:STH
#spell_slot += Shock:zok
#spell_slot += Simulacrum:scm
#spell_slot += Silence:SLC
#spell_slot += Slow:swlh
#spell_slot += Spellforged servitor:spvt
#spell_slot += Spider form:sprf
#spell_slot += Static discharge:tdc
#spell_slot += Statue form:stmf
#spell_slot += Sticky flame:yfk
#spell_slot += Sting:zptg
#spell_slot += Stone arrow:wtn
#spell_slot += Storm form:somf
#spell_slot += Summon forest:ftms
#spell_slot += Summon guardian golem:gds
#spell_slot += Summon horrible things:hts
#spell_slot += Summon hydra:hsy
#spell_slot += Summon ice beast:bct
#spell_slot += Summon lightning spire:lst
#spell_slot += Summon mana viper:vms
#spell_slot += Summon small mammal:zsm
#spell_slot += Swiftness:ieao
#spell_slot += Teleport other:tprh
#spell_slot += Tornado:TDN
#spell_slot += Tukima's Dance:dkc
#spell_slot += Vampiric draining:vnd
#spell_slot += Wereblood:wbld
#spell_slot += Yara's violent unraveling:yvgl

# Default letters
spell_slot += .*:hjklyubn

##################
### Item slots ###
##################

## Rings, in order of letter used.
item_slot += ring of dexterity : Dd
item_slot += ring of evasion : Ee
item_slot += ring of .*fire : Ff
item_slot += ring of (ice|protection from cold) : Cc
item_slot += ring of intelligence : Ii
item_slot += ring of flight : L
item_slot += ring of magical power : Mm
item_slot += ring of positive energy : Nn
item_slot += ring of poison resistance : P
item_slot += ring of resist corrosion : R
item_slot += ring of strength : Ss
item_slot += ring of see invisible : v
item_slot += ring of willpower: Ww
# Need numeric match to not trigger for rF/rC rings
item_slot += \+[0-9]+ ring of protection : Tt
item_slot += ring of slaying : Yy
item_slot += ring of wizardry : Zz

########################
### Autoinscriptions ###
########################

#  !*	Will prompt before any action with this item.
#  !a	Will prompt before attacking with this item.
#  !w	Will prompt before wielding or unwielding this item.
#  !e	Will prompt before eating.
#  !q	Will prompt before quaffing.
#  !r	Will prompt before reading.
#  !f	Will prompt before throwing or firing.
#  !W	Will prompt before wearing armour.
#  !T	Will prompt before taking off armour.
#  !P	Will prompt before putting on jewellry.
#  !R	Will prompt before removing jewellry.
#  !v	Will prompt before evoking an item.
#  !Q	Will prompt before quivering an item.
#  !p	Will prompt before sacrificing a anything in a stack containing this item.
# =p	Will prompt before sacrificing this item, but allows stack to be sacrificed.
# =g	Will automatically pick this item up if autopickup is on.
# =k	Will be ignored in listings on the ground.
# =s	If stash tracking is explicit, dropping this marks a stash to be tracked.
# =f	This item will be excluded with cycling ammunition and in automatic quivering.
# +f	This item is included in cycling ammunition and automatic quivering.
#  !D	Will prompt before performing any action that might destroy this item.

show_god_gift = unident

ai := autoinscribe

#ai += .*potion:!q
#ai += .*scroll:!r

# Confirmation required.
#ai += [a\|0-9] .* potions?:!q
#ai += scrolls? labelled:!r

ai += scrolls? of (summoning|silence|vulnerability|immolation|fog|butterflies|teleport|fear|torment):!r

ai += potions? of mutation:!q
ai += potions? of berserk rage:!q
ai += scrolls? of silence:!r

ai += of faith:!P
ai += manual of:!d
# Prevent melee with all staves; if we want to melee with one, it's safe to
# require removing the annotation.
ai += magical staff:!a
ai += (large rock|throwing net|curare|of dispersal):=f

# Convenient shortcuts
ai += potions? of curing:@q1
ai += potions? of heal wounds:@q2
ai += potions? of haste:@q3
ai += potions? of cancellation:@q4
ai += scrolls? of identify:@r1
ai += scrolls? of blink:@r2
ai += scrolls? of teleportation:@r3

ai += datura:Berserk =f
ai += atropa:Blindness =f
ai += curare:Toxic =f

#ai += potion:!q
#ai += scroll:!r


##############
### Morgue ###
##############

note_hp_percent = 10
note_all_skill_levels = true
note_chat_messages = false
user_note_prefix = >>

note_items += experience,of resistance, Archmagi
note_items += crystal plate armour,pearl dragon scales
note_items += artefact
note_messages += You feel monstrous
note_messages += You pass through the gate
note_messages += cast .* Abyss

# Noteable monsters
# Undead
note_monsters += ancient lich, dread lich,curse skull,curse toe,royal mummy
# Depths
note_monsters += caustic shrike
# Special hall_of_zot spawns
note_monsters += killer klown,electric golem,orb of fire

dump_message_count = 1000
dump_order  = header,hiscore,stats,misc,mutations,skills,spells,inventory
dump_order += overview,screenshot,monlist,messages,skill_gains,action_counts
dump_order += vaults,notes,kills,turns_by_place,xp_by_level

dump_kill_places = all
dump_item_origins = all
dump_book_spells = false


########runrest.rc########

# Aliases
stop := runrest_stop_message
ignore := runrest_ignore_message

# Ignore these stops
interrupt_travel -= sense_monster
interrupt_travel -= mimic

# Monsters to ignore at a distance
runrest_ignore_monster += fire vortex:1
runrest_ignore_monster += neutral:1

# Message mutes: CAREFUL WITH THESE!
message_colour += mute:plain:No target in view!

# Stop for consumables you want to use immediately
stop += potions? of experience
stop += scrolls? of acquirement

# Don't stop for noisy doors unless someone shouts back
stop -= it creaks loudly
stop -= flies open with a bang
stop += You hear

# Re-enable stops for all ally actions then ignore some
ignore -= friend_action:
ignore -= friend_spell:
ignore -= friend_enchant:
ignore ^= butterfly disappears
ignore ^= friend_action:(a|the) web
ignore ^= friend_action:(seems|blinks)
stop += friend_action:
stop += friend_spell:
stop += friend_enchant:
stop += appears from out of your range of vision
stop += hits your
stop += our.*is destroyed

# Expiring effects; Turn on transmutation|flight|swiftness ending and ignore the rest
ignore -= transformation is almost over\.
ignore -= transformation has ended\.
ignore -= revert to a slightly less stony form\.
ignore -= revert to your normal fleshy form\.
ignore -= You feel yourself come back to life
ignore ^= unholy channel is weakening
ignore ^= magical contamination.*faded
ignore ^= our foxfire dissipates
stop ^= transformation is almost over
stop ^= transformation has ended
stop ^= revert to a slightly less stony form\.
stop ^= revert to your normal fleshy form
stop ^= feel yourself come back to life
stop ^= unholy channel expires
stop ^= are starting to lose your buoyancy
stop ^= feel.*sluggish
# Expiring effects for friends too
stop ^= no longer petrified
ignore ^= no longer covered in acid

# Misc
stop -= You now have enough gold to

ignore ^= nearby plant withers and dies
ignore ^= disentangle yourself
ignore ^= You swap places.

# Summonings
ignore ^= our.*crimson imp blinks
ignore ^= our.*simulacrum vaporises
ignore ^= our.*returns to the shadows of the Dungeon
ignore ^= our.*skeleton crumbles into dust
ignore ^= our.*fades into mist

########fm-messages.rc########

# Alias
more := force_more_message

# Remove annoying defaults
more -= You have reached level
more -= The lock glows eerily
more -= Heavy smoke blows from the lock
more -= The gate opens wide
more -= With a soft hiss the gate opens wide
more -= You pick up the .* rune and feel its power


# Significant spells/effects ending
more += is no longer charmed
more += You are starting to lose your buoyancy
# Death's Door
more += time is.*running out
more += life is in your own
# Death channel
more += unholy channel is weakening


# Monsters doing things
more += monster_warning:wielding.*of chaos
more += monster_warning:carrying a wand of
more += monster_warning:curare
more += (?<!You)(?<!yourself) speeds? up
more += danger:goes berserk
more += The forest starts to sway and rumble
more += begins to recite a word of recall
more += doors? slams? shut
more += blows on a signal horn
more += The.*offers itself to Yredelemnul
more += Deactivating autopickup
more += Your?.*suddenly stops? moving
more += There is.*feeling in your soul
more += swoops through the air toward you
more += Its appearance distorts for a moment
more += wretched star pulses
more += Strange energies course through your body


# Crowd control
more += You ((?<!( too|less)) confused|blown|knocked back|mesmerised|trampled|stumble backwards|encased|(?<!hands )slow.*down|lose consciousness)
more += infuriates you
more += danger:Space.*around you
more += hits you.*distortion
more += The pull of.*song draws you forward
more += The.*engulfs you in water
more += surroundings become eerily quiet
more += Your limbs are stiffening
more += Your magical effects are unraveling
more += Your magical defenses are stripped away
more += You stop (a|de)scending the stairs
more += A sentinel's mark forms upon you


# Clouds
more += danger:(calcify|mutagenic)
more += You are engulfed in.*miasma
more += Miasma billows from the


# You Screwed Up
more += power of Zot
more += is no longer ready
more += You really shouldn't be using
more += You don't have enough magic to cast this spell
more += Your body shudders with the violent release


# Found something important
more += Found a staircase to the Ecumenical Temple
more += timed_portal:.*
more += Found.*(treasure|bazaar|ziggurat)
more += .*resides here
more += You have a vision of.*gates?


# Translocations
more += You blink
more += danger:You feel strangely .*stable
more += danger:sense of stasis
more += Your surroundings.*(different|flicker)
more += You are suddenly pulled into a different region
more += delayed


# Big damage
more += your body is wracked
more += Ouch! That really hurt!
more += silver sears you
more += The poison in your body grows stronger
more += You.*re (more poisoned|lethally poisoned)
more += danger:You convulse
more += You feel a (horrible|terrible) chill
more += You are (blasted|electrocuted|burned terribly)


# Hit by something
more += Terrible wounds
more += danger:corrodes you
more += The air around.*erupts in flames
more += The air twists around and violently strikes you in flight
more += You shudder from the earth-shattering force
more += You feel.*(?<!less )(haunted|rot|vulnerable)
more += Your damage is reflected back at you
more += (?<!You.*)reflects


# FYI
more += seems mollified
more += You have finished your manual


# Unexpected monsters
more += appears in a (shower|flash)
more += appears out of thin air
more += You sense the presence of something unfriendly
more += Wisps of shadow swirl around


# Misc
more += hell effect:.*
more += god:wrath finds you
more += The walls disappear
more += guardian golem overheats


## If you understand this, I trust you not to troll me
more += dgl_message:.*


###########
### Lua ###
###########


########fm-monsters.rc########

{
------------------------------------------------------------------------------------------
------------------------------- Monster force_mores config -------------------------------
------------------------------------------------------------------------------------------
-- This stops on all Uniques & Pan lords
crawl.setopt("force_more_message += monster_warning:(?!Orb)(?!Guardian)(?-i:[A-Z]).*comes into view")

---- Everything included in this list will cause a more() prompt.
---- It should contain monsters that always need alerts, regardless of HP, xl, willpower, and resistances
local force_more_monsters = {
  -- High damage/speed
    "shrike", "juggernaut", "orbs? of fire", "flayed ghost",
  -- Torment
    "tormentor", "curse (toe|skull)", "Fiend", "tzitzimi", "royal mummy", "mummy priest", "(dread|ancient) lich", "lurking horror",
  --Summoning
    "boggart", "shadow demon", "guardian serpent", "ironbound convoker", "draconian stormcaller", "spriggan druid", "dryad",
    "worldbinder", "halazid warlock", "deep elf elementalist", "demonspawn corrupter", "elemental wellspring",
  --Dangerous abilities
    "swamp worm", "floating eye", "vault warden", "air elemental", "wendingo", "torpor snail", "dream sheep", "water nymph", 
    "shambling mangrove", "iron giant", "starflower", "merfolk aquamancer", "deep elf knight", "wretched star",
  --Dangerous clouds
    "catoblepas", "death drake", "apocalypse crab", "putrid mouth" }


------------------------------------------------------------------------------------------
------------------------------- Dynamic force_mores config -------------------------------
------------------------------------------------------------------------------------------
-- hp-specific force_mores() by gammafunk, willpower/int/resistance added by sockthot
local fm_patterns = {
  -- Fast, early game Dungeon problems for chars with low mhp.
  {name = "30hp", cond = "hp", cutoff = 30, pattern = "hound"},
  
  -- Monsters dangerous until a certain point
  {name = "xl_7", cond = "xl", cutoff = 7, pattern = "orc wizard"},
  {name = "xl_12", cond = "xl", cutoff = 12, pattern = "hydra|bloated husk"},
  
  
  -- Monsters that can hit for ~50% of hp from range with unbranded attacks
  {name = "40hp", cond = "hp", cutoff = 40, pattern = "orc priest" },
  {name = "50hp", cond = "hp", cutoff = 50, pattern = "orc high priest|manticore" },
  {name = "70hp", cond = "hp", cutoff = 70, pattern = "meliai|yaktaur(?! captain)|cyclops" },
  {name = "80hp", cond = "hp", cutoff = 80, pattern = "centaur(?! warrior)|gargoyle" },
  {name = "90hp", cond = "hp", cutoff = 90, pattern = "deep elf archer|tengu conjurer" },
  {name = "110hp", cond = "hp", cutoff = 110, pattern = {"centaur warrior|yaktaur captain|hellion|eye of devastation|sun moth",
              "deep elf high priest|deep troll earth mage|stone giant|cacodemon"} },
  {name = "120hp", cond = "hp", cutoff = 120, pattern = "quicksilver (dragon|elemental)|magenta draconian|thorn hunter" },
  {name = "160hp", cond = "hp", cutoff = 160, pattern = {"brimstone fiend|deep elf sorcerer",
              "hell sentinal|war gargoyle|draconian (knight|scorcher)"} },
  {name = "200hp", cond = "hp", cutoff = 200, pattern = "(draconian|deep elf) annihilator|iron (dragon|elemental)" },

  -- Monsters that can crowd-control you without sufficient willpower
  -- Cutoff ~10% for most spells; lower for more significant spells like banish
  {name = "willpower2", cond = "will", cutoff = 2, pattern = "basilisk|naga ritualist|vampire(?! bat)(?! mage)(?! mosquito)" },
  {name = "willpower3", cond = "will", cutoff = 3, pattern = {"deep elf (demonologist|sorcerer|archer)|(?<!orc )wizard", 
              "merfolk siren|fenstrider witch|great orb of eyes|cacodemon|imperial myrmidon|sphinx|nagaraja|draconian shifter",
              "orange crystal statue|glowing orange brain|orc sorcerer|ogre mage|satyr|vault sentinel",
              "iron elemental|golden eye|death knight|vampire knight" } },
  {name = "willpower4", cond = "will", cutoff = 4, pattern = "merfolk avatar|tainted leviathan|nargun" },
   
  -- Malmutate without rMut
  {name = "malmutate", cond = "mut", cutoff = 1, pattern = "cacodemon|neqoxec|shining eye" },
    
  -- Brain feed with low int
  {name = "brainfeed", cond = "int", cutoff = 6, pattern = "glowing orange brain|neqoxec|orange crystal statue" },
    
  -- Alert if no resist and HP below cutoff
  {name = "pois_30", cond = "pois", cutoff = 30, pattern = "adder"},
  {name = "pois_80", cond = "pois", cutoff = 80, pattern = "golden dragon|green draconian|swamp dragon" },
  {name = "pois_120", cond = "pois", cutoff = 120, pattern = "green death|naga mage|nagaraja|fenstrider witch" },
  {name = "pois_140", cond = "pois", cutoff = 140, pattern = "tengu reaver" },
   
  {name = "elec_40", cond = "elec", cutoff = 40, pattern = "electric eel" },
  {name = "elec_80", cond = "elec", cutoff = 80, pattern = "shock serpent|raiju|spark wasp" },
  {name = "elec_120", cond = "elec", cutoff = 120, pattern = "black draconian|blizzard demon|deep elf zephyrmancer|storm dragon|tengu conjurer" },
  {name = "elec_140", cond = "elec", cutoff = 140, pattern = "electric golem|titan|servants? of whisper|spriggan air mage|ball lightning|tengu reaver" },
   
  {name = "corr_60", cond = "corr", cutoff = 60, pattern = "acid dragon" },
  {name = "corr_140", cond = "corr", cutoff = 140, pattern = "tengu reaver|entropy weaver|demonspawn corrupter|moon troll" },
   
  {name = "fire_60", cond = "fire", cutoff = 60, pattern = "steam dragon|lindwurm|fire crab|lava snake" },
  {name = "fire_100", cond = "fire", cutoff = 100, pattern = "efreet|deep elf pyromancer|smoke demon|sun moth" },
  {name = "fire_120", cond = "fire", cutoff = 120, pattern = "orc sorcerer|hell hound|demonspawn blood saint|red draconian|ogre mage|molten gargoyle|hell knight" },
  {name = "fire_140", cond = "fire", cutoff = 140, pattern = "balrug" },
  {name = "fire_160", cond = "fire", cutoff = 160, pattern = "will-o-the-wisp|ophan|fire giant|golden dragon|fire dragon|salamander tyrant|tengu reaver" },
  {name = "fire_240", cond = "fire", cutoff = 240, pattern = "hellephant|crystal (guardian|echidna)|draconian scorcher" },
   
  {name = "cold_80", cond = "cold", cutoff = 80, pattern = "rime drake" },
  {name = "cold_120", cond = "cold", cutoff = 120, pattern = "blizzard demon|bog body|ironbound frostheart|demonspawn blood saint|white draconian" },
  {name = "cold_160", cond = "cold", cutoff = 160, pattern = "golden dragon|draconian knight|frost giant|ice dragon|tengu reaver" },
  {name = "cold_180", cond = "cold", cutoff = 180, pattern = "(?>!dread)(?>!ancient) lich" },
  {name = "cold_240", cond = "cold", cutoff = 240, pattern = "crystal (guardian|echidna)" },
   
  {name = "drain_100", cond = "drain", cutoff = 100, pattern = "orc sorcerer" },
  {name = "drain_120", cond = "drain", cutoff = 120, pattern = "necromancer" },
  {name = "drain_150", cond = "drain", cutoff = 150, pattern = "revenant|demonspawn blood saint" },
  {name = "drain_190", cond = "drain", cutoff = 190, pattern = "shadow dragon" },
   
} -- end fm_patterns

----------------------------------------------------------------------------------
------------------------------- End config section -------------------------------
----------------------------------------------------------------------------------



-- Add the non-dynamic force_mores()  (moved code down here for easier configuration)
local fm_mon_str = nil
for _, v in ipairs(force_more_monsters) do
  if fm_mon_str == nil then
    fm_mon_str = "monster_warning:(?<!spectral )("..v
  else
    fm_mon_str = fm_mon_str.."|"..v
  end
end
fm_mon_str = fm_mon_str..")(?! (zombie|skeleton|simulacrum).*comes into view"
crawl.setopt("force_more_message += "..fm_mon_str)




-- Set to true to get a message when the fm change
local notify_fm = false

-- Keep track of active force_mores()
local active_fm = {}
for i,v in ipairs(fm_patterns) do
  active_fm[#active_fm + 1] = false
end

-- Util for checks against resistance and hp
local function get_three_pip_action(active, hp, cutoff, res)
  if active then
    if hp >= cutoff then return "-" end
    if res == 1 and hp >= cutoff/2 then return "-" end
    if res == 2 and hp >= cutoff/3 then return "-" end
    if res == 3 and hp >= cutoff/5 then return "-" end
  else
    if res == 0 and hp < cutoff then return "+" end
    if res == 1 and hp > cutoff/2 then return "+" end
    if res == 2 and hp > cutoff/3 then return "+" end
    if res == 3 and hp > cutoff/5 then return "+" end
  end
end



--------------------------------------------
------------------- Hook -------------------
--------------------------------------------
function ready_force_mores()
  local activated = {}
  local deactivated = {}
  
  local hp, maxhp = you.hp()
  local willpower = you.willpower()
  local res_mut = you.res_mutation()
  local res_pois = you.res_poison()
  local res_elec = you.res_shock()
  local res_corr = you.res_corr()
  local res_fire = you.res_fire()
  local res_cold = you.res_cold()
  local res_drain = you.res_draining()
  local int, maxint = you.intelligence()
  
  for i,v in ipairs(fm_patterns) do
    local msg = nil
    if type(v.pattern) == "table" then
      for j, p in ipairs(v.pattern) do
        if not msg then
          msg = p
        else
          msg = msg .. "|" .. p
        end
      end
    else
      msg = v.pattern
    end
    
    msg = "monster_warning:(?<!spectral )(" .. msg .. ")(?! (skeleton|zombie|simulacrum)).*comes into view"
    
    local action = nil
    local fm_name = v.pattern
    if v.name then fm_name = v.name end
    
    if not v.cond and not active_fm[i] then
      action = "+"
    elseif v.cond == "xl" then
      if active_fm[i] and you.xl() >= v.cutoff then action = "-"
      elseif not active_fm[i] and you.xl() < v.cutoff then action = "+"
      end
    elseif v.cond == "maxhp" then
      if active_fm[i] and maxhp >= v.cutoff then action = "-"
      elseif not active_fm[i] and maxhp < v.cutoff then action = "+"
      end
    elseif v.cond == "hp" then
      if active_fm[i] and hp >= v.cutoff then action = "-"
      elseif not active_fm[i] and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "int" then
      if active_fm[i] and int >= v.cutoff then action = "-"
      elseif not active_fm[i] and int < v.cutoff then action = "+"
      end
    elseif v.cond == "will" then
      if active_fm[i] and willpower >= v.cutoff then action = "-"
      elseif not active_fm[i] and willpower < v.cutoff then action = "+"
      end
    elseif v.cond == "mut" then
      if active_fm[i] and res_mut > 0 then action = "-"
      elseif not active_fm[i] and res_mut == 0 then action = "+"
      end
    elseif v.cond == "pois" then
      if active_fm[i] and (res_pois > 0 or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and res_pois == 0 and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "elec" then
      if active_fm[i] and (res_elec > 0 or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and res_elec == 0 and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "corr" then
      if active_fm[i] and (res_corr or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and not res_corr and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "fire" then
      action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_fire)
    elseif v.cond == "cold" then
      action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_cold)
    elseif v.cond == "drain" then
      action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_drain)
    end
    
    
    if action == "+" then
      activated[#activated + 1] = fm_name
    elseif action == "-" then
      deactivated[#deactivated + 1] = fm_name
    end
    if action then
      local opt = "force_more_message " .. action .. "= " .. msg
      crawl.setopt(opt)
      active_fm[i] = not active_fm[i]
    end
  end
  if #activated > 0 and notify_fm then
    crawl.mpr("Activating force_mores: " .. table.concat(activated, ", "), "plain")
  end
  if #deactivated > 0 and notify_fm then
    crawl.mpr("Deactivating force_mores: " .. table.concat(deactivated, ", "), "plain")
  end
end
}

########dynamic-options.rc########

{
----------------------
---- race-specific ----
----------------------
if you.race() == "Demonspawn" then
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
elseif you.race() == "Formicid" then
  crawl.setopt("more -= monster_warning:curare")
elseif you.race() == "Gargoyle" then
  crawl.setopt("more -= monster_warning:curare")
elseif you.race() == "Ghoul" then
  crawl.setopt("more -= monster_warning:curare")
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
elseif you.race() == "Gnoll" then
  crawl.setopt("message_colour ^= mute:intrinsic_gain:skill increases to level")
elseif you.race() == "Mummy" then
  crawl.setopt("more -= monster_warning:curare")
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
end


----------------------
---- god-specific ----
----------------------
local cur_god = "No God"
local function set_god_options()
  if you.god() ~= cur_god then
    cur_god = you.god()
  
    if cur_god == "Beogh" then
      crawl.setopt("autopickup_exceptions ^= >scrolls? of immolation")
      crawl.setopt("runrest_ignore_message += no longer looks unusually strong")
      crawl.setopt("force_more_message += Your orc.*dies")
      crawl.setopt("macros += M 1 tf")
      crawl.setopt("macros += M 2 ta")
      crawl.setopt("macros += M 3 tr")
      crawl.setopt("macros += M 4 tg")
      crawl.setopt("macros += M 6 ab")
    elseif cur_god == "Dithmenos" then
      crawl.setopt("force_more_message += god:You are shrouded in an aura of darkness")
      crawl.setopt("force_more_message += god:You now sometimes bleed smoke")
      crawl.setopt("force_more_message += god:You.*no longer.*bleed smoke")
      crawl.setopt("force_more_message += god:Your shadow no longer tangibly mimics your actions")
      crawl.setopt("force_more_message += god:Your shadow now sometimes tangibly mimics your actions")
    elseif cur_god == "Fedhas" then
      crawl.setopt("force_more_message += god:Fedhas invokes the elements against you")
    elseif cur_god == "Hepliaklqana" then
      crawl.setopt("runrest_ignore_message ^= emerges from the mists of memory")
    elseif cur_god == "Jiyva" then
      crawl.setopt("force_more_message += god:will now unseal the treasures of the Slime Pits")
      crawl.setopt("force_more_message += god:Jiyva alters your body")
      crawl.setopt("force_more_message += god:splits in two")
      crawl.setopt("force_more_message += god:Your prayer is over.")
    elseif cur_god == "Kikubaaqudgha" then
      crawl.setopt("force_more_message += god:Kikubaaqudgha will grant you")
    elseif cur_god == "Lugonu" then
      crawl.setopt("force_more_message += god:Lugonu will now corrupt your weapon")
      crawl.setopt("force_more_message += god:Lugonu sends minions to punish you")
    elseif cur_god == "Okawaru" then
      crawl.setopt("force_more_message += god:Okawaru sends forces against you")
    elseif cur_god == "Qazlal" then
      crawl.setopt("force_more_message += god:resistances upon receiving elemental damage")
      crawl.setopt("force_more_message += god:You are surrounded by a storm which can block enemy attacks")
    elseif cur_god == "The Shining One" then
      crawl.setopt("force_more_message += god:Your divine shield starts to fade.")
      crawl.setopt("force_more_message += god:Your divine shield fades away.")
    elseif cur_god == "Trog" then
      crawl.setopt("force_more_message += god:You feel the effects of Trog's Hand fading")
      crawl.setopt("force_more_message += god:You feel less resistant to hostile enchantments")
    elseif cur_god == "Uskayaw" then
      crawl.setopt("force_more_message += god:You can no longer pass through a line of other dancers.")
    elseif cur_god == "Wu Jian Council" then
      crawl.setopt("runrest_ignore_message += heavenly storm settles")
    elseif cur_god == "Xom" then
      crawl.setopt("force_more_message += god:")
      crawl.setopt("force_more_message += staircase.*moves")
      crawl.setopt("force_more_message += Some monsters swap places")
    elseif cur_god == "Yredelemnul" then
      crawl.setopt("force_more_message += god:soul is now ripe for the taking")
      crawl.setopt("force_more_message += god:soul is no longer ripe for the taking")
      crawl.setopt("force_more_message += god:dark mirror aura disappears")
    elseif cur_god == "Zin" then
      crawl.setopt("force_more_message += god:will now cure all your mutations")
    end
  end
end



---------------------
---- xl-specific ----
---------------------
local warn_early_levels = false
local warn_mid_levels = false
local function set_xl_options()
  if not warn_early_levels and you.xl() <= 5 then
    warn_early_levels = true
    crawl.setopt("force_more_message += wielding.*(vorpal|(?<!armour)(?<!mail)(?<!scales) of)")
  elseif warn_early_levels and you.xl() > 5 then
    warn_early_levels = false
    crawl.setopt("force_more_message -= wielding.*(vorpal|(?<!armour)(?<!mail)(?<!scales) of)")
  end
  
  if not warn_mid_levels and you.xl() <= 10 then
    warn_mid_levels = true
    crawl.setopt("force_more_message += wielding.*of electrocution")
  elseif warn_mid_levels and you.xl() > 10 then
    warn_mid_levels = false
    crawl.setopt("force_more_message -= wielding.*of electrocution")
  end
end


------------------------
---- skill-specific ----
------------------------
local ignoring_spellcasting = false
local function set_skill_options()
  -- Ignore spellcaster items if you have no spellcasting skill, and wearing some armour without much armour skill
  local arm = items.equipped_at("body armour")
  if not ignoring_spellcasting and you.skill("Spellcasting") == 0 and arm and arm.encumbrance > you.skill("Armour") then
    ignoring_spellcasting = true
    crawl.setopt("explore_stop_pickup_ignore += spellbooks")
    crawl.setopt("autopickup_exceptions ^= >scrolls? of amnesia, >potions? of brilliance, >ring of wizardry")
    crawl.setopt("runrest_ignore_message += You add the spell")
  elseif ignoring_spellcasting and not (you.skill("Spellcasting") == 0 and arm and arm.encumbrance > you.skill("Armour")) then
    ignoring_spellcasting = false
    crawl.setopt("explore_stop_pickup_ignore -= spellbooks")
    crawl.setopt("autopickup_exceptions -= >scrolls? of amnesia, >potions? of brilliance, >ring of wizardry")
    crawl.setopt("runrest_ignore_message -= You add the spell")
  end
end



------------------------------------------
------------------ Hook ------------------
------------------------------------------
function ready_dynamic_options()
  set_god_options()
  set_xl_options()
  set_skill_options()
end

}

########startup.rc########

{
-------------------------------------------------
---- Start with travel speed to slowest ally ----
-------------------------------------------------
-- Make sure this comes before Skill menu on startup, since they both use crawl.sendkeys()
local need_toggle_travel_speed = true
if you.turns() == 0 and need_toggle_travel_speed then
  need_toggle_travel_speed = false
  crawl.sendkeys(20)
end


---------------------------------------------
---- Skill menu on startup (by rwbarton) ----
---------------------------------------------
local need_skills_opened = true
if you.turns() == 0 and need_skills_opened then
  need_skills_opened = false
  crawl.sendkeys("m!!")
end

}

### Pickup and alert ###


########pickup-alert/pa-util.rc########

{
function show_alert_msg(alert_text, item_name)
  crawl.mpr("<cyan>----<magenta>"..alert_text.."<yellow>"..item_name.."</yellow></magenta>----</cyan>")
end


function insert_item_and_less_enchanted(table_name, item_name)
  -- Add an item name to a table, along with all less enchanted versions
  -- e.g. "+3 flail" will add: "+3 flail", "+2 flail", "+1 flail", "+0 flail"
  if util.contains(table_name, item_name) then return end
  table.insert(table_name, item_name)

  -- Add less enchanted items too
  local plus = tonumber(item_name:sub(2,2))
  if not plus then return end
    
  if plus > 0 then
    if tonumber(item_name:sub(3,3)) then
      plus = 10 * plus + tonumber(item_name:sub(3,3))
    end

    for i=plus,1,-1 do
      item_name = item_name:gsub("+"..i, "+"..(i-1))
      table.insert(table_name, item_name)
    end
  end
end


function has_ego(it)
  if it.class(true) == "weapon" then return it.branded end
  
  if it.artefact then return true end
  if it.branded then return true end
  local qualname = it.name("qual")
  if qualname:find("troll leather") then return true end
  if qualname:find("dragon scales") then return true end
  return false
end


function get_size_factor()
  local race = you.race()
  if race == "Spriggan" then return 4
  elseif race == "Kobold" then return 2
  elseif race == "Formicid" or race == "Armataur" or race == "Naga" or race == "Ogre" or race == "Troll" then return -2
  else return 0
  end
end


function get_shield_penalty(sh)
  return 2/5 * sh.encumbrance * sh.encumbrance / (20 - 3 * get_size_factor()) * (27 - you.skill("Shields")) / 27
end


local summon_gods = { "Beogh", "Jiyva", "Yredelemnul" }
function you_have_summons()
  return you.skill("Summonings") + you.skill("Necromancy") > 0 or util.contains(summon_gods, you.god())
end

--------------------------------------------------
--------------------- Armour ---------------------
--------------------------------------------------
function get_armour_ac(it)
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end
  
  if it.artefact and it.fully_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end

  if it.artefact and it.fully_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end
  
  local it_ac = it.ac
  if you.get_base_mutation_level("deformed body", true, false, false) > 0 then it_ac = it_ac / 2 end
  
  return it_ac * (you.skill("Armour") / 22 + 1) + it_plus 
end


function get_shield_sh(it)
  local dex = you.dexterity()
  if it.artefact and it.fully_identified then
    local art_dex = it.artprops["Dex"]
    if art_dex then dex = dex + art_dex end
  end
  
  local cur = items.equipped_at("shield")
  if cur and cur.artefact and cur.slot ~= it.slot then
    local art_dex = cur.artprops["Dex"]
    if art_dex then dex = dex - art_dex end
  end

  local it_plus = it.plus
  if not it_plus then it_plus = 0 end
  
  local it_ac = it.ac
  if you.get_base_mutation_level("deformed body", true, false, false) > 0 then it_ac = it_ac / 2 end
  
  local block = it_ac
  local race = you.race()
  if race == "Spriggan" then
    if it.name("base"):find("buckler") then block = block + 2 end
  elseif race == "Kobold" then
    local basename = it.name("base")
    if basename:find("buckler") then block = block + 1
    elseif basename:find("kite shield") then block = block + 0.5 end
  elseif race == "Ogre" or race == "Troll" then
    if it.name("base"):find("kite shield") then block = block - 0.5 end
  end
  
  
  local stat_bonus = dex * 38 * (it_ac + 13) / 5200
  
  local skill = you.skill("Shields")
  local addend
  if skill >= 3 then addend = .38*skill
  else addend = .57 + 0.19*skill
  end
  
  return block * (1+skill/40) + it_plus + stat_bonus + addend
end

function get_armour_ev(it)
  -- This function computes the armour-based component to standard EV (not paralysed, etc)
  -- Factors in stat changes from this armour and removing current one
  local str = you.strength()
  local dex = you.dexterity()
  local art_ev = 0
  
  
  -- Adjust str/dex/EV for artefact stat changes
  local worn = items.equipped_at("body armour")
  if worn and worn.artefact then
    if worn.artprops["Str"] then str = str - worn.artprops["Str"] end
    if worn.artprops["Dex"] then dex = dex - worn.artprops["Dex"] end
    if worn.artprops["EV"] then art_ev = art_ev - worn.artprops["EV"] end
  end
  
  local no_art_dex = dex
  
  if it.artefact then
    if it.artprops["Str"] then str = str + it.artprops["Str"] end
    if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
    if it.artprops["EV"] then art_ev = art_ev + it.artprops["EV"] end
  end
  
  local size_factor = get_size_factor()
  
  
  local dodge_bonus = (8 + you.skill("Dodging") * dex) / (20 - size_factor)
  local normalize_zero_to_zero = (8 + you.skill("Dodging") * no_art_dex) / (20 - size_factor)

  armor_penalty = it.encumbrance - 3
  local modifier = 0
  if armor_penalty <= 0 then modifier = 1
  elseif armor_penalty > 0 then
    if armor_penalty >= str then modifier = str / (armor_penalty * 2)
    else modifier = 1 - armor_penalty / (str * 2)
    end
  end

  local final_dodge_bonus = dodge_bonus * modifier
  local aevp = 2 * it.encumbrance * it.encumbrance * (45 - you.skill("Armour")) / (5 * (str + 3) * 45)

  return final_dodge_bonus - aevp + art_ev - normalize_zero_to_zero
end


---------------------------------------------------
--------------------- Weapons ---------------------
---------------------------------------------------
function get_hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  st, _ = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end


function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Intended only to be used to prevent skill from reducing too far in get_weap_delay()
  local basename = it.name("base")
  local st, _ = it.subtype()
  local base_delay = it.delay
  
  local min_delay = base_delay / 2
  if it.weap_skill == "Short Blades" and min_delay > 5 then min_delay = 5 end
  if min_delay > 7 then min_delay = 7 end
  
  if basename:find("longbow") then min_delay = 6
  elseif (basename:find("crossbow") or basename:find("arbalest")) and min_delay < 10 then min_delay = 10 end
  
  return min_delay
end


function get_weap_delay(it)
  local delay = it.delay - you.skill(it.weap_skill)/2
  local min_delay = get_weap_min_delay(it)
  if delay < min_delay then delay = min_delay end
  
  if it.ego() == "Speed" then delay = delay * 2 / 3 end
  
  if delay < 3 then delay = 3 end
  
  local sh = items.equipped_at("shield")
  if sh then delay = delay + get_shield_penalty(sh) end
  
  return delay / 10
end


function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaik
  for i = 0,20 do
    it = items.equipped_at(i)
    if it then
      if it.name("base") == "ring" then
        if it.artefact then
          local name = it.name()
          local idx = name:find("Slay+")
          if idx then
            local slay = tonumber(name:sub(idx+5, idx+5))
            if slay == 1 then
              local next_digit = tonumber(name:sub(idx+6, idx+6))
              if next_digit then slay = 10 + next_digit end
            end
            sum = sum + slay
          end
        elseif it.ego(true) == "Slay" then 
          sum = sum + it.plus 
        end
      elseif it.artefact and (it.class(true) == "armour" or it.name("base") == amulet) then
          local slay = it.artprops["Slay"]
          if slay then sum = sum + slay end
      end
    end
  end
  
  if you.race() == "Demonspawn" then
    sum = sum + 3 * you.get_base_mutation_level("augmentation", true, false, true)
    sum = sum + you.get_base_mutation_level("sharp scales", true, false, true)
  end

  return sum
end


function get_staff_bonus_dmg(it, no_brand_dmg)
  if no_brand_dmg and basename ~= "staff of earth" and basename ~= "staff of conjuration" then return 0 end
  
  local evo_skill = you.skill("Evocations")
  local basename = it.name("base")
  local school
  if basename == "staff of fire" then school = "Fire Magic"
  elseif basename == "staff of cold" then school = "Ice Magic"
  elseif basename == "staff of earth" then school = "Earth Magic"
  elseif basename == "staff of air" then school = "Air Magic"
  elseif basename == "staff of poison" then school = "Poison Magic"
  elseif basename == "staff of death" then school = "Necromancy"
  elseif basename == "staff of conjuration" then school = "Conjurations"
  else
    crawl.mpr("ERROR:UNRECOGNIZED STAFF:"..it.name("base"), error)
    return 0
  end
  
  local spell_skill = you.skill(school)
  local chance = (evo_skill + spell_skill/2) / 15
  if chance > 1 then chance = 1 end
  -- 0.625 is an acceptable approximation
  -- Earth magic does more, but reduced by armour. Poison/draining bonus effects are ignored.
  local avg_dmg = 0.625 * (evo_skill/2 + spell_skill)
  return avg_dmg*chance
end


function get_weap_dps(it, no_brand_dmg)
  -- Returns an adjusted weapon damage = damage * speed
  -- Includes stat/slay changes between weapon and the one currently wielded
  -- Aux attacks not included
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end

  -- Adjust str/dex/slay from artefacts
  local str = you.strength()
  local dex = you.dexterity()
  
  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local wielded = items.equipped_at("weapon")
    if wielded and wielded.artefact then
      if wielded.artprops["Str"] then str = str - wielded.artprops["Str"] end
      if wielded.artprops["Dex"] then dex = dex - wielded.artprops["Dex"] end
      if wielded.artprops["Slay"] then it_plus = it_plus - wielded.artprops["Slay"] end
    end
    
    if it.artefact and it.fully_identified then
      if it.artprops["Str"] then str = str + it.artprops["Str"] end
      if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
      if it.artprops["Slay"] then it_plus = it_plus + it.artprops["Slay"] end
    end
  end
  
  if it.is_ranged or it.weap_skill:find("Blades") then stat = dex
  else stat = str end

  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + you.skill(it.weap_skill)/25/2) * (1 + you.skill("Fighting")/30/2)
  
  local pre_brand_dmg = it.damage * stat_mod * skill_mod + it_plus + get_slay_bonuses()
  
  
  if it.class(true) == "magical staff" then 
    return (pre_brand_dmg + get_staff_bonus_dmg(it, no_brand_dmg)) / get_weap_delay(it)
  end
  
  local ego = it.ego()
  if not ego then return pre_brand_dmg / get_weap_delay(it) end

  if ego == "spectralizing" then return 2 * pre_brand_dmg / get_weap_delay(it) end
  if ego == "vorpality" then
    if it.is_ranged then return 1.2 * pre_brand_dmg / get_weap_delay(it) end
    return 7/6 * pre_brand_dmg / get_weap_delay(it)
  end
  
  if not no_brand_dmg then
    if ego == "flaming" or ego == "freezing" then return 1.25 * pre_brand_dmg  / get_weap_delay(it) end
    if ego == "draining" then return (1.25 * pre_brand_dmg + 2) / get_weap_delay(it) end 
    if ego == "electrocution" then return (pre_brand_dmg + 3.5) / get_weap_delay(it) end
    -- Ballparking venom as 5 dmg since it totally breaks the paradigm
    if ego == "venom" then return (pre_brand_dmg + 5) / get_weap_delay(it) end
    if ego == "pain" then return (pre_brand_dmg + you.skill("Necromancy")/2) / get_weap_delay(it) end
    -- Distortion does 5.025 extra dmg, + 5% chance to banish
    if ego == "distortion" then return (pre_brand_dmg + 6) / get_weap_delay(it) end
    -- Weighted average of all the easily computed brands was ~ 1.17*dmg + 2.13
    if ego == "chaos" then return (1.25 * pre_brand_dmg + 2) / get_weap_delay(it) end
  end
  
  return pre_brand_dmg / get_weap_delay(it)
end


-----------------------------
---- Weapon info strings ----
-----------------------------
function get_weapon_info(it)
  if not it.weap_skill then return end
  local dps = get_weap_dps(it)
  local dps_str = string.format("%.2f", dps)
      
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end
  local acc = it.accuracy + it_plus
  if acc >= 0 then acc = "+"..acc end
  
  dps_str = "DPS="..dps_str
  if dps < 10 then dps_str = dps_str.." " end
  return dps_str.."(Acc"..acc..")"
end


function get_armour_info(it)
  if not it or it.class(true) ~= "armour" then return end
  
  if it.subtype() == "shield" then
    local ev = get_shield_penalty(it)
    local ev_str = string.format("%.1f", ev)
    ev_str = "-"..ev_str
  
    local sh = get_shield_sh(it)
    local sh_str = string.format("%.1f", sh)
    if sh >= 0 then sh_str = "+"..sh_str end
    sh_str = "SH"..sh_str..","
    if sh < 10 then sh_str = sh_str.." " end

    return sh_str.."EV"..ev_str
  else
    local ac = get_armour_ac(it)
    local ac_str = string.format("%.1f", ac)
    if ac >= 0 then ac_str = "+"..ac_str end
    if it.subtype() ~= "body" then return "AC"..ac_str end
    
    ac_str = "AC"..ac_str..","
    if ac < 10 then ac_str = ac_str.." " end


    local ev = get_armour_ev(it)
    local ev_str = string.format("%.1f", ev)
    if ev >= 0 then ev_str = "+"..ev_str end
    return ac_str.."EV"..ev_str
  end  
end
}

########pickup-alert/pa-data.rc########

{

-------------------------------------------------------------------------------
---------------------------- Begin persistant data ----------------------------
-------------------------------------------------------------------------------
if not added_persistant_data or you.turns() == 0 then
  added_persistant_data = 1
  
  items_picked = { "" }
  items_alerted = { "" }
  rare_items = {"broad axe", "executioner's axe", "eveningstar", "demon whip", "sacred scourge",
                "lajatang", "bardiche", "demon trident", "trishula",
                "quick blade", "demon blade", "double sword", "triple sword", "eudemon blade",
                "crystal plate armour", "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales", 
                "triple crossbow", "hand crossbow", "buckler", "kite shield", "tower shield" }


  armour_high_score = 0
  local eq = items.equipped_at("body armour")
  if eq then armour_high_score = get_armour_ac(eq) end

  alerted_first_ranged_one_handed = 0
  alerted_first_ranged_two_handed = 0
  polearm_high_score = 0
  polearm_onehand_high_score = 0
  unbranded_high_score = 0
  weapon_high_score = 0
  
  eq = items.equipped_at("weapon")
  if eq then
    local eq_dmg = get_weap_dps(eq) + eq.accuracy + eq.plus
    weapon_high_score = eq_dmg
    unbranded_high_score = get_weap_dps(eq, true) + eq.accuracy + eq.plus
    
    if eq.is_ranged then
      if get_hands(eq) == 1 then alerted_first_ranged_one_handed = 1
      else alerted_first_ranged_two_handed = 1 end
    elseif eq.weap_skill == "Polearms" then
      polearm_high_score = eq_dmg
      if get_hands(eq) == 1 then polearm_onehand_high_score = eq_dmg end
    end
  end
end


local function persist_table(table_name, table)
  local cmd = table_name.." = {"
  local len = 0
  for _,v in ipairs(table) do
    if v ~= "" then
      cmd = cmd .. "\"" .. v .. "\", "
      len = len+1
    end
  end

  return cmd .. "\"\"}" .. string.char(10)
end

local function persist_var(var_name, var)
  return var_name .. " = " .. var .. string.char(10)
end


if not added_persistant_data_hooks then
  added_persistant_data_hooks = true
  
  table.insert(chk_lua_save, function() return persist_table("rare_items", rare_items) end)
  table.insert(chk_lua_save, function() return persist_table("items_picked", items_picked) end)
  table.insert(chk_lua_save, function() return persist_table("items_alerted", items_alerted) end)
  table.insert(chk_lua_save, function() return persist_var("armour_high_score", armour_high_score) end)
  table.insert(chk_lua_save, function() return persist_var("alerted_first_ranged_one_handed", alerted_first_ranged_one_handed) end)
  table.insert(chk_lua_save, function() return persist_var("alerted_first_ranged_two_handed", alerted_first_ranged_two_handed) end)
  table.insert(chk_lua_save, function() return persist_var("polearm_high_score", polearm_high_score) end)
  table.insert(chk_lua_save, function() return persist_var("polearm_onehand_high_score", polearm_onehand_high_score) end)
  table.insert(chk_lua_save, function() return persist_var("unbranded_high_score", unbranded_high_score) end)
  table.insert(chk_lua_save, function() return persist_var("weapon_high_score", weapon_high_score) end)
  
  table.insert(chk_lua_save, function() return persist_var("added_persistant_data", 1) end)
end

----------------------------------------
---- Accessors into persistant data ----
----------------------------------------
function pickup_item(it)
  local ret_val = false
  local name = it.name("plain")
  if not it.fully_identified then
    name = "+0 " .. name
  end

  if it.artefact then
    ret_val = true
  elseif not util.contains(items_picked, name) then
    -- Add to the table on pickup, in c_assign_invletter() hook function
    ret_val = true
  end
  
  -- Remove from rare_items if it's there
  for i,v in ipairs(rare_items) do
    if v ~= "" and name:find(v) then
      rare_items[i] = ""
      return true
    end
  end
  
  -- Returns true if we haven't picked up this item previously
  return ret_val
end

function check_high_scores(it)
  local ret_val = nil
  
  if it.class(true) == "armour" then
    local ac = get_armour_ac(it)
    if ac > armour_high_score then
      armour_high_score = ac
      if not ret_val then ret_val = "Strongest armour" end
    end
  elseif it.class(true) == "weapon" then
    local it_plus = it.plus
    if not it_plus then it_plus = 0 end
    local score = get_weap_dps(it) + (it.accuracy + it_plus) / 2
    if score > weapon_high_score then
      weapon_high_score = score
      if not ret_val then ret_val = "Good weapon" end
    end
    
    local unbranded_score = get_weap_dps(it, false) + (it.accuracy + it_plus) / 2
    if unbranded_score > unbranded_high_score then
      unbranded_high_score = score
      if not ret_val then ret_val = "High pure damage" end
    end
    
    if it.weap_skill == "Polearms" then
      if score > polearm_high_score then
        polearm_high_score = score
        if not items.equipped_at("shield") and not ret_val then ret_val = "Good polearm" end
      end

      if get_hands(it) == 1 and score > polearm_onehand_high_score then
        polearm_onehand_high_score = score
        if not ret_val then ret_val = "1-handed polearm" end
      end
    end
  end

  return ret_val
end

function c_assign_invletter_item_alerts(it)
  if it.weap_skill or it.class(true) == "armour" then
    local name = it.name("plain")
    if not util.contains(items_picked, name) then
      insert_item_and_less_enchanted(items_picked, name)
      insert_item_and_less_enchanted(items_alerted, name)
      check_high_scores(it)
      
      for i, v in ipairs(rare_items) do
        if name:find(v) then rare_items[i] = "" end
      end
    end
  end
end


function alert_item(it, alert_type)
  local name = it.name("plain")
  
  if (it.artefact or it.branded) and not it.fully_identified then
    if util.contains(items_alerted, name) then return end
    table.insert(items_alerted, name)
    show_alert_msg("Item alert, "..alert_type..": ", name)
    return
  end
  
  -- Prefix unidentified items with "+0"
  if not it.fully_identified then
    name = "+0 " .. name
  end

  if not util.contains(items_alerted, name) then
    if it.class(true) == "weapon" or it.class(true) == "magical staff" then
      show_alert_msg("Item alert, "..alert_type..": ", name.." "..get_weapon_info(it))
    elseif it.class(true) == "armour" then
      show_alert_msg("Item alert, "..alert_type..": ", name.." "..get_armour_info(it))    
    else
      show_alert_msg("Item alert, "..alert_type..": ", name)
    end

    insert_item_and_less_enchanted(items_alerted, name)
  end
  
  -- Returns true to make other code more concise; indicates that we tried to alert this item
  return true
end
crawl.setopt("runrest_stop_message += Item alert, ")


function get_rare_item_index(it)
  local qualname = it.name("qual")
  for i,v in ipairs(rare_items) do
    if v ~= "" and qualname:find(v) then 
    return i end
  end
  return -1
end

-----------------------------------------------------------------------------
---------------------------- End persistant data ----------------------------
-----------------------------------------------------------------------------
}

########pickup-alert/pa-main.rc########


{

------------------------------------
---- Autopickup and alerts hook ----
------------------------------------
add_autopickup_func(function (it, name)
  local class = it.class(true)
  
  -- Check for pickup
  local retVal = false
  if class == "armour" and loaded_pa_armour then retVal = pickup_armour(it)
  elseif class == "weapon" and loaded_pa_weapons then retVal = pickup_weapons(it)
  elseif class == "magical staff" and loaded_pa_misc then retVal = pickup_staves(it)
  end
  
  if retVal == true then return pickup_item(it) end

  
  -- Not picking up this item. Check for alerts
  if it.name("base") == "orb" and loaded_pa_misc then alert_orbs(it)
  elseif class == "armour" and loaded_pa_armour then alert_armour(it)
  elseif class == "weapon" and loaded_pa_weapons then alert_weapons(it)
  end
  if loaded_pa_misc then
    alert_rare_items(it)
    if class == "magical staff" then alert_staves(it) end
  end
end)
-------------------------------
---- End autopickup master ----
-------------------------------
}

########pickup-alert/pa-armour.rc########


{
loaded_pa_armour = true



---------------------------------------
---- Begin alert_armour_upgrades() ----
---------------------------------------
-- If training armour in early/mid game, alert user to any armour that is the strongest found so far

local function alert_armour_upgrades(it)
  if you.skill("Armour") == 0 then return false end
  if you.xl() > 12 then return false end
  if (it.artefact or it.branded) and not it.fully_identified then return false end

  local st, _ = it.subtype()
  if st ~= "body" then return false end

  if armour_high_score == 0 then
    local cur = items.equipped_at("body armour")
    if not cur then return false end
    armour_high_score = get_armour_ac(cur)
  else
    local itAC = get_armour_ac(it)
    if itAC > armour_high_score+0.3 then
      armour_high_score = itAC
      return alert_item(it, "Stronger armour")
    end
  end
  
  return false
end
-------------------------------------
---- End alert_armour_upgrades() ----
-------------------------------------

-------------------------------
---- Begin pickup_armour() ----
-------------------------------
-- Equipment autopickup (by Medar, gammafunk, sockthot, and various others)
function pickup_armour(it)
  if it.is_useless then return false end
  
  local st, _ = it.subtype()
 
  if st == "body" then
    -- Body armour: AC upgrades, new egos that don't lose AC, and artefacts that don't lose 5+ AC
    local cur = items.equipped_at("body armour")
    if not cur then return false end
    if not it.fully_identified and it.branded then return false end
    
    if it.encumbrance <= cur.encumbrance then
      local ac_delta = get_armour_ac(it) - get_armour_ac(cur)
      
      if it.artefact and ac_delta > -5 then return true end
      if cur.artefact then return false end
      
      if it.ego() == cur.ego() and (has_ego(it) or not has_ego(cur)) then
        if ac_delta > 0 then return true end
        return false
      elseif has_ego(it) and not (cur.artefact or has_ego(cur)) then
        if ac_delta >= 0 then return true end
      end
    end
  elseif st == "shield" then
    -- Shields
    if not it.fully_identified or it.name("base") == "orb" then return false end
    
    local cur = items.equipped_at("shield")
    if not cur then return false end
    if cur.name("base") ~= it.name("base") then return false end
    if it.artefact then return true end
    if cur.artefact then return false end
    if cur.branded then
      if cur.ego() == it.ego() then return it.plus > cur.plus end
      return false
    end
    if it.branded then return true end
    return it.plus > cur.plus
  else
    -- Aux armour: Pickup artefacts, AC upgrades, and new egos
    
    -- No pickup if mutation interference
    if st == "gloves" then
      -- Ignore demonic touch if you're wearing a shield
      if not items.equipped_at("shield") then
        if you.get_base_mutation_level("demonic touch", true, false, true) > 0 then return false end
      end
      
      -- Ignore claws if you're wielding a weapon
      if not items.equipped_at("weapon") then
        if you.get_base_mutation_level("claws", true, false, true) > 0 then return false end
      end
    elseif st == "boots" then
      if you.get_base_mutation_level("hooves", true, false, true) > 0 then return false end
      if you.get_base_mutation_level("talons", true, false, true) > 0 then return false end
    elseif it.name("base"):find("helmet") then
      if you.get_base_mutation_level("horns", true, false, true) > 0 then return false end
      if you.get_base_mutation_level("beak", true, false, true) > 0 then return false end
      if you.get_base_mutation_level("antennae", true, false, true) > 0 then return false end
    end

    if it.artefact then return true end

    local cur = items.equipped_at(st)
    if not cur then return true end
    if not it.fully_identified then return false end

    if it.branded then
      if it.ego() ~= cur.ego() then return true end
      if get_armour_ac(it) > get_armour_ac(cur) then return true end
    else
      if cur.branded or cur.artefact then return false end
      if get_armour_ac(it) > get_armour_ac(cur) then return true end
    end
  end

  return false
end
-----------------------------
---- End pickup_armour() ----
-----------------------------


--------------------------------------------
---- Begin alert_armour_while_mutated() ----
--------------------------------------------
-- Special cases where you have temporary or innate mutations that interfere with armour
local function alert_armour_while_mutated(it, type)
  -- Alerts usable ego items if there are mutations
  -- Returns before alerting if innate mutations make item unusable
  -- Returns true iff there are mutations
  if type == "gloves" then
    local claws_lvl_innate = you.get_base_mutation_level("claws", true, false, false)
    if claws_lvl_innate >= 3 then return true end
  
    local touch_lvl_innate = you.get_base_mutation_level("demonic touch", true, false, false)
    if touch_lvl_innate >= 3 then return true end

    local claws_lvl = you.get_base_mutation_level("claws", true, false, true)
    local touch_lvl = you.get_base_mutation_level("demonic touch", true, false, true)
    
    if claws_lvl + touch_lvl > 0 then
      if it.artefact or it.branded then return alert_item(it, "Branded gloves") end
      return true
    end
  elseif type == "boots" then
    local hooves_lvl_innate = you.get_base_mutation_level("hooves", true, false, false)
    if hooves_lvl_innate >= 3 then return true end
  
    local talons_lvl_innate = you.get_base_mutation_level("talons", true, false, false)
    if talons_lvl_innate >= 3 then return true end
  
    local hooves_lvl = you.get_base_mutation_level("hooves", true, false, true)
    local talons_lvl = you.get_base_mutation_level("talons", true, false, true)

    if hooves_lvl + talons_lvl > 0 then
      if it.artefact or it.branded then return alert_item(it, "Branded boots") end
      return true
    end
  elseif type == "helmet" then
    local horns_lvl_innate = you.get_base_mutation_level("horns", true, false, false)
    local antennae_lvl_innate = you.get_base_mutation_level("antennae", true, false, false)

    if it.name("base"):find("helmet") then
      if horns_lvl_innate > 0 then return true end
      if antennae_lvl_innate > 0 then return true end
      if you.get_base_mutation_level("beak", true, false, false) > 0 then return true end
    else
      -- hat/crown/etc
      if horns_lvl_innate >= 3 then return true end
      if antennae_lvl_innate >= 3 then return true end
    end
  
    local horns_lvl = you.get_base_mutation_level("horns", true, false, true)
    local antennae_lvl = you.get_base_mutation_level("antennae", true, false, true)
    local beak_lvl = you.get_base_mutation_level("beak", true, false, true)
    if horns_lvl + antennae_lvl + beak_lvl > 0 then
      if it.artefact or it.branded then return alert_item(it, "Branded headgear") end
      return true
    end
  end
  
  return false
end
--------------------------------------------
---- End alert_armour_while_mutated() ----
--------------------------------------------

------------------------------------------
---- Begin alert_interesting_armour() ----
------------------------------------------
local function alert_interesting_armour(it)
  if it.artefact then 
    if not it.fully_identified then return false end
    return alert_item(it, "Artefact armour")
  end
  local st, _ = it.subtype()

  if st == "body" then
    local cur = items.equipped_at("body armour")
    if not cur then return false end
    
    if it.encumbrance == cur.encumbrance then
      if has_ego(it) then
        if not has_ego(cur) then return alert_item(it, "Added ego") end
        if it.ego() ~= cur.ego() then return alert_item(it, "New ego") end
      end
      if get_armour_ac(it) > get_armour_ac(cur) then return alert_item(it, "Stronger armour1") end
    
    elseif it.encumbrance < cur.encumbrance then
      -- Lighter armour
      local ev_gain = get_armour_ev(it) - get_armour_ev(cur)
      local ac_lost = get_armour_ac(cur) - get_armour_ac(it)
      
      if has_ego(it) then
        if not cur.artefact and not has_ego(cur) then
          if ev_gain >= 0.6 * ac_lost or ac_lost <= 6 then return alert_item(it, "Added ego1") end
        elseif it.ego() ~= cur.ego() then
          if ev_gain >= 0.8 * ac_lost or ac_lost <= 6 then return alert_item(it, "New ego1") end
        else
          -- Same ego
          if ev_gain >= 1.2 * ac_lost then return alert_item(it, "Lighter armour1") end
        end
      else
        if cur.artefact or has_ego(cur) then
          -- Lost ego
          if ev_gain >= 2 * ac_lost then return alert_item(it, "Lighter armour2") end
        else
          -- Neither has ego
          if ev_gain >= 1.2 * ac_lost then return alert_item(it, "Lighter armour3") end
        end
      end
    else
      -- Heavier armour
      local ac_gain = get_armour_ac(it) - get_armour_ac(cur)
      local ev_lost = get_armour_ev(cur) - get_armour_ev(it)
      local encumb_penalty = 0
      if you.skill("Spellcasting") > 1 then encumb_penalty = (it.encumbrance - cur.encumbrance)/2 end
      
      
      if has_ego(it) then
        if not cur.artefact and not has_ego(cur) then
          if ac_gain >= 0.4 * ev_lost or ev_lost <= 8 then return alert_item(it, "Added ego2") end
        elseif it.ego() ~= cur.ego() then
          if ac_gain >= 0.6 * ev_lost or ev_lost <= 8 then return alert_item(it, "New ego2") end
        else
          -- Same ego
          if ac_gain >= 0.8 * ev_lost + encumb_penalty then return alert_item(it, "Stronger armour2") end
        end
      else
        if cur.artefact or has_ego(cur) then
          -- Lost ego
          if ac_gain >= 1 * ev_lost + encumb_penalty then return alert_item(it, "Stronger armour3") end
        else
          -- Neither has ego
          if ac_gain >= 0.8 * ev_lost + encumb_penalty then return alert_item(it, "Stronger armour4") end
        end
      end
    end
  elseif st == "shield" then
    local cur = items.equipped_at("shield")
    if not cur then return false end
    if it.branded and it.ego() ~= cur.ego() then
      return alert_item(it, "New egoS")
    end
  else
    -- Aux armour
    local cur = items.equipped_at(st)
    if cur and not it.is_useless and get_armour_ac(it) > get_armour_ac(cur) then return alert_item(it, "Stronger armour5") end
    return alert_armour_while_mutated(it, st)
  end
end
----------------------------------------
---- End alert_interesting_armour() ----
----------------------------------------

function alert_armour(it)
  if not it.is_useless then alert_armour_upgrades(it) end
  if it.fully_identified or not it.branded then alert_interesting_armour(it) end
end

}

########pickup-alert/pa-weapons.rc########


{
loaded_pa_weapons = true

--------------------------
---- Begin inv arrays ----
--------------------------
-- Use these arrays to compare potential upgrades against entire inventory
local top_school = "unarmed combat"
local all_schools = { "axes", "maces & flails", "long blades", "short blades", "staves", "unarmed combat", "ranged weapon" }
local function set_top_school()
  local max = 0
  
  for _, v in ipairs(all_schools) do
    if you.skill(v) > max then
      max = you.skill(v)
      top_school = v
    end
  end
end


local inv_max_dmg = { melee = 0, melee_b = 0, twohands = 0, twohands_b = 0, ranged = 0, ranged_b = 0 }
local inv_max_dmg_acc = { melee = 0, melee_b = 0, twohands = 0, twohands_b = 0, ranged = 0, ranged_b = 0 }
local egos = { }

local function get_weap_type(it)
  if it.is_ranged then
    if it.branded then return "ranged_b"
    else return "ranged" end
  else
    if get_hands(it) == 2 then
      if it.branded then return "twohands_b"
      else return "twohands" end
    else
      if it.branded then return "melee_b"
      else return "melee" end
    end
  end
end

local function enforce_dmg_floor(target, floor)
  if inv_max_dmg[target] < inv_max_dmg[floor] then
    inv_max_dmg[target] = inv_max_dmg[floor]
    inv_max_dmg_acc[target] = inv_max_dmg_acc[floor]
  end
end

local function generate_inv_weap_arrays()
  set_top_school()
  
  for cur in iter.invent_iterator:new(items.inventory()) do
    if cur.class(true) == "weapon" then
      if cur.ego() then table.insert(egos, cur.ego()) end
      
      local dmg = get_weap_dps(cur)
      local weap_type = get_weap_type(cur)
      if dmg > inv_max_dmg[weap_type] then
        inv_max_dmg[weap_type] = dmg
        inv_max_dmg_acc[weap_type] = cur.accuracy + cur.plus
      end
    end
  end
  
  enforce_dmg_floor("melee", "melee_b")
  enforce_dmg_floor("twohands_b", "melee_b")
  enforce_dmg_floor("twohands", "twohands_b")
  enforce_dmg_floor("twohands", "melee")
  enforce_dmg_floor("ranged", "ranged_b")
end
------------------------
---- End inv arrays ----
------------------------



-------------------------------
---- alert_early_weapons() ----
-------------------------------
-- Alert strong weapons early
local function alert_early_weapons(it)
  -- Alert really good usable ranged weapons
  if you.xl() <= 14 then
    if it.fully_identified and it.is_ranged then
      if it.branded and it.plus >= 5 or it.plus >= 7 then
        if get_hands(it) == 1 or not items.equipped_at("shield") or you.skill("shield") <= 8 then
          return alert_item(it, "Ranged weapon9")
        end
      end
    end
  end

  -- Skip items when we're clearly going another route
  if you.skill(top_school) - you.skill(it.weap_skill) > 1.5*you.xl()+3 then return end


  if you.xl() <= 8 then
    if it.branded or it.plus and it.plus >= 4 then
      -- Make sure we don't alert a pure downgrade to something in inventory
      for inv in iter.invent_iterator:new(items.inventory()) do
        if inv.name("base") == it.name("base") then
          if inv.plus >= it.plus then
            if not it.branded then return end
            if it.ego() == inv.ego() then return end
          end
        end
      end
      
      return alert_item(it, "Early weapon")
    end
  end
end


----------------------------
---- Alert first ranged ----
----------------------------
local function alert_first_ranged(it)
  if not it.is_ranged then return false end
  
  if get_hands(it) == 2 then
    if items.equipped_at("shield") then return false end
    if alerted_first_ranged_two_handed == 0 then
      alerted_first_ranged_two_handed = 1
      for inv in iter.invent_iterator:new(items.inventory()) do
        if inv.is_ranged and get_hands(inv) == 2 then return true end
      end
      return alert_item(it, "Ranged weapon5")
    end
  else
    if alerted_first_ranged_one_handed == 0 then
      alerted_first_ranged_one_handed = 1
      for inv in iter.invent_iterator:new(items.inventory()) do
        if inv.is_ranged then return true end
      end
      return alert_item(it, "Ranged weapon6")
    end
  end
  
  return false
end

--------------------------------
---- Begin pickup_weapons() ----
--------------------------------

local function pickup_weapon(it, cur)
  if cur.subtype() == it.subtype() then
    -- Exact weapon type match
    if it.artefact then return true end
    if cur.artefact then return false end
    if it.branded and it.fully_identified and not cur.branded then return true end
    if cur.branded and not it.branded then return false end
    return it.ego() == cur.ego() and get_weap_dps(it) > get_weap_dps(cur)
  elseif you.skill(it.weap_skill) >= 0.5 * you.skill(cur.weap_skill) then
    -- A usable weapon school
    -- Replace cur weapon if new one does more damage, unless there are potential benefits to cur
    if get_hands(it) > get_hands(cur) then return false end
    if it.is_ranged ~= cur.is_ranged then return false end
    if cur.weap_skill == "Polearms" and it.weap_skill ~= "Polearms" then return false end
    
    if it.artefact then return true end
    if cur.artefact then return false end
    if it.branded and not it.fully_identified then return false end
    if cur.branded and not it.branded then return false end

    local dmg_delta
    if get_weap_dps(cur) > inv_max_dmg[get_weap_type(it)] then 
      dmg_delta = get_weap_dps(it) - get_weap_dps(cur)
    else
      dmg_delta = get_weap_dps(it) - inv_max_dmg[get_weap_type(it)]
    end
    
    if dmg_delta > 0 then return true end
    local it_plus = it.plus
    if not it_plus then it_plus = 0 end
    return dmg_delta == 0 and (it.accuracy+it_plus) > inv_max_dmg_acc[get_weap_type(it)]
  end
  
  return false
end



function pickup_weapons(it)
  if it.is_useless then return false end
  
  generate_inv_weap_arrays()
  local unarmed = true

  for cur in iter.invent_iterator:new(items.inventory()) do
    if cur.class(true) == "weapon" then
      if pickup_weapon(it, cur) then
        return true
      end
      if not cur.is_ranged then
        unarmed = false
      end
    end
  end
  
  -- Return false unless you need a weapon but don't have one yet
  if not unarmed or you.skill("Unarmed Combat") > 0 then return false end
  if you.get_base_mutation_level("claws", true, false, true) > 0 then return false end
  if you.get_base_mutation_level("demonic touch", true, false, true) > 0 then return false end
  
  return true
end

------------------------------
---- End pickup_weapons() ----
------------------------------

-------------------------------------------
---- Begin alert_interesting_weapons() ----
-------------------------------------------
local function alert_interesting_weapon(it, cur)
  if it.artefact and it.fully_identified then return alert_item(it, "Artefact weapon") end
  
  if cur.subtype() == it.subtype() then
    -- Exact weapon type match
    if it.branded and it.ego() ~= cur.ego() then return alert_item(it, "New ego1") end
    if get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then return alert_item(it, "Stronger weapon0") end
  elseif you.skill(it.weap_skill) >= 0.5 * you.skill(cur.weap_skill) then
    -- A usable weapon school
    if it.is_ranged ~= cur.is_ranged then return false end
    --local penalty = 1
    --if it.weap_skill == top_school then penalty = 0.5 end
    local penalty = 0.5 * you.skill(cur.weap_skill) / you.skill(it.weap_skill)
    if get_hands(it) == 2 and get_hands(cur) == 1 then
      -- Item requires an extra hand
      if it.branded and not cur.artefact and not cur.branded then
        if get_weap_dps(it) > 0.8*get_weap_dps(cur) then return alert_item(it, "2-handed weapon1") end
      end
      
      if not items.equipped_at("shield") then 
        if it.branded and it.ego() ~= cur.ego() then return alert_item(it, "New ego") end
        if not (cur.branded or cur.artefact) and get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then return alert_item(it, "2-handed weapon2") end
        if (cur.branded or cur.artefact) and not it.branded and get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then return alert_item(it, "2-handed weapon3") end
      elseif you.skill("shields") <= 4 then
        -- Not really training shields; may be interested in big upgrades
        if get_weap_dps(it) >= penalty*2*inv_max_dmg["melee"] then return alert_item(it, "2-handed weapon4") end
      end
    else
      -- Item uses same number of hands or fewer
      if cur.artefact then return false end
      if it.branded then
        local dmg_delta = get_weap_dps(it) - inv_max_dmg[get_weap_type(it)]
        if not cur.branded then
          if dmg_delta >= -4/penalty then return alert_item(it, "New ego2") end
        elseif it.ego() == cur.ego() then
          if dmg_delta >= 0 then return alert_item(it, "Stronger weapon1") end
        elseif not util.contains(egos, it.ego()) then
          if dmg_delta >= -4/penalty then return alert_item(it, "New ego3") end
        end
      else
        -- Not branded
        if cur.branded then
          if get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then
              return alert_item(it, "Stronger weapon2")
          end
        else
          local dmg_delta, other_acc
          if get_weap_dps(cur) > inv_max_dmg[get_weap_type(it)] then 
            dmg_delta = get_weap_dps(it) - get_weap_dps(cur)
            other_acc = cur.accuracy + cur.plus
          else
            dmg_delta = get_weap_dps(it) - inv_max_dmg[get_weap_type(it)]
            other_acc = inv_max_dmg_acc[get_weap_type(it)]
          end
          
          if dmg_delta > 0 then return alert_item(it, "Stronger weapon3") end
          local it_plus = it.plus
          if not it_plus then it_plus = 0 end
          if dmg_delta == 0 and (it.accuracy+it_plus) > other_acc then return alert_item(it, "Higher accuracy") end
        end
      end      
    end
  end
end


local function alert_interesting_weapons(it)
  generate_inv_weap_arrays()
  
  local ranged_weap_in_inv = false
  for cur in iter.invent_iterator:new(items.inventory()) do
    if cur.class(true) == "weapon" then
      if alert_interesting_weapon(it, cur) then return true end
      if cur.is_ranged then ranged_weap_in_inv = true end
    end
  end
  
  -- Alert for the first ranged weapon found (for 1 and 2 handed separately)
  if it.is_ranged and not ranged_weap_in_inv then
    if it.artefact or it.branded and it.plus >= 4 then
      if items.equipped_at("shield") then
        local qualname = it.name("qual")
        if qualname:find("hand crossbow") or qualname:find("sling") then
          return alert_item(it, "Ranged Weapon1")
        end
      else
        return alert_item(it, "Ranged Weapon2")
      end
    end
  end
  
  return false
end
-----------------------------------------
---- End alert_interesting_weapons() ----
-----------------------------------------

local function alert_high_scores(it)
  local category = check_high_scores(it)
  if category then alert_item(it, category) end
end

function alert_weapons(it)
  if it.is_useless then return end
  if (it.artefact or it.branded) and not it.fully_identified then return end
  
  alert_interesting_weapons(it)
  alert_first_ranged(it)
  alert_early_weapons(it)
  alert_high_scores(it)
end
}

########pickup-alert/pa-misc.rc########


{
loaded_pa_misc = true


--------------------------
---- Alert rare items ----
--------------------------
function alert_rare_items(it)
  local index = get_rare_item_index(it)
  if index == -1 then return end
  
  local do_alert = true
  -- Don't alert if already wearing a larger shield
  if rare_items[index] == "buckler" then
    local sh = items.equipped_at("shield")
    if sh and sh.name("base") ~= "orb" then do_alert = false end
  elseif rare_items[index] == "kite shield" then
    local sh = items.equipped_at("shield")
    if sh and sh.name("base"):find("tower shield") then do_alert = false end
  end
    
  if do_alert then
    -- Found a new rare item! We may already have one if it was auto-picked up
    show_alert_msg("It's your first ", rare_items[index].."!")
    crawl.more()
  end

  rare_items[index] = ""
  
  return
end
crawl.setopt("runrest_stop_message += It's your first.*!")


--------------------
---- Alert orbs ----
--------------------
function alert_orbs(it)
  if items.equipped_at("shield") then return false end
  if not it.fully_identified then return false end
  alert_item(it, "New orb")
  return false
end



----------------------------
---- Smart staff pickup ----
----------------------------
function pickup_staves(it)
  if it.is_useless or not it.fully_identified then return false end

  local basename = it.name("base")
  local good_staff = false
  if basename == "staff of fire" then good_staff = you.skill("Fire Magic") > 0
  elseif basename == "staff of cold" then good_staff = you.skill("Ice Magic") > 0
  elseif basename == "staff of earth" then good_staff = you.skill("Earth Magic") > 0
  elseif basename == "staff of air" then good_staff = you.skill("Air Magic") > 0
  elseif basename == "staff of poison" then good_staff = you.skill("Poison Magic") > 0
  elseif basename == "staff of death" then good_staff = you.skill("Necromancy") > 0
  elseif basename == "staff of conjuration" then good_staff = you.skill("Conjurations") > 0
  else crawl.mpr("Unrecognized staff: " .. basename, "error")
  end
  
  if good_staff == true then
    return true
  end
  
  return false
end


------------------------
---- alert_staves() ----
------------------------
function alert_staves(it)
  if not it.fully_identified then return false end
  local needRes = false
  local basename = it.name("base")
  
  if basename == "staff of fire" then needRes = you.res_fire() == 0
  elseif basename == "staff of cold" then needRes = you.res_cold() == 0
  elseif basename == "staff of air" then needRes = you.res_shock() == 0
  elseif basename == "staff of poison" then needRes = you.res_poison() == 0
  elseif basename == "staff of death" then needRes = you.res_draining() == 0
  end
  
  if needRes == true then
    return alert_item(it, "Staff resistance")
  end
  
  return false
end

}

### Features ###


########features/inscribe-stats.rc########

{

local function inscribe_armour_stats(it)
  local new_inscr = get_armour_info(it)
  local idx
  if it.subtype() == "shield" then idx = it.inscription:find("SH+")
  else idx = it.inscription:find("AC+")
  end
  
  if idx then
    if idx + #new_inscr <= #it.inscription then
      new_inscr = new_inscr..it.inscription:sub(idx + #new_inscr, #it.inscription)
    end
    if idx > 1 then new_inscr = it.inscription:sub(1, idx-1)..new_inscr end
  end

  it.inscribe(new_inscr, false)
  return new_inscr
end

local function inscribe_weapon_stats(it)
  local new_inscr = get_weapon_info(it)
      
  local idx = it.inscription:find("DPS=")
  if idx then
    if idx + #new_inscr <= #it.inscription then
      new_inscr = new_inscr..it.inscription:sub(idx + #new_inscr, #it.inscription)
    end
    if idx > 1 then new_inscr = it.inscription:sub(1, idx-1)..new_inscr end
  end

  it.inscribe(new_inscr, false)
  return new_inscr
end


------------------------------------------
------------------ Hook ------------------
------------------------------------------
function c_message_inscribe_dps(text, channel)
  for it in iter.invent_iterator:new(items.inventory()) do
    local class = it.class(true)
    if class == "weapon" or class == "magical staff" then
  inscribe_weapon_stats(it)
    elseif class == "armour" then
      inscribe_armour_stats(it)
    end
  end
end
}

########features/remind-id.rc########

{
-------------------------------------
---- Unidentified items reminder ----
-------------------------------------
local function remind_unidentified_items(have_unidentified)
  for it in iter.invent_iterator:new(items.inventory()) do
    if not it.fully_identified then
      for s in iter.invent_iterator:new(items.inventory()) do
        if s and s.name("qual"):find("scroll of identify") then
          crawl.mpr("<magenta>----You have something to identify.----</magenta>", "plain")
        end
      end
      
      return
    end
  end
end
crawl.setopt("runrest_stop_message += You have something to identify")



---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_message_remind_identify(text, channel)
  if channel ~= "plain" then return end

  if text:find(" of identify") and not text:find("drop") and not text:find("read") then
    remind_unidentified_items(false)
  end
end

function c_assign_invletter_remind_identify(it)
  if not it.fully_identified then remind_unidentified_items(true) end
end
}

########features/weapon-slots.rc########

{
------------------------------
---- Cleanup weapon slots ----
------------------------------
--Whenever you drop an item:
    -- Assign weapons to slots a and b
        -- Priority: 1:wielded, 2:weapon, not polearm/ranged unless skill
        -- 3:magical staff, 4:polearm
    -- Assign weap to w: ranged/polearm/any


local function get_first_empty_slot()
  for slot=1,52 do
    if not items.inslot(slot) then return slot end
  end
end

local function get_priority_ab(it)
  if not it or not it.weap_skill then return -1 end
  if it.equipped then return 1 end
  
  local class = it.class(true)
  if class == "magical staff" then return 3 end
  if class == "weapon" then
    if it.is_ranged then    
      if you.skill("Ranged Weapons") >= 4 then return 2 end
      return 5
    end
    
    if it.weap_skill == "Polearms" then
      if you.skill("Polearms") >= 4 then return 2 end
      return 4
    end
    
    return 2
  end
  
  return -1
end

local function get_priority_w(it)
  if not it or not it.weap_skill then return -1 end
  if it.is_ranged then return 1 end
  if it.weap_skill == "Polearms" then return 2 end
  return 3
end



--------------
---- main ----
--------------
local priorities_ab = nil
local priorities_w = nil
local function generate_priorities()
  priorities_ab = { -1, -1, -1, -1, -1 }
  priorities_w = { -1, -1, -1 }
  
  for it in iter.invent_iterator:new(items.inventory()) do
    local p = get_priority_w(it)
    if p > 0 then
      if priorities_w[p] == -1 then priorities_w[p] = it.slot
      else priorities_w[p+1] = it.slot
      end
    end
    
    p = get_priority_ab(it)
    if p > 0 then
      if priorities_ab[p] == -1 then priorities_ab[p] = it.slot
      else priorities_ab[p+1] = it.slot
      end
    end
  end
end


local function cleanup_w()
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if inv and inv.class(true) == "weapon" then return end

  for p=1,3 do
    if priorities_w[p] > 1 then
      items.swap_slots(priorities_w[p], slot_w)
      return
    end
  end
end

local function cleanup_ab(ab)
  local inv
  inv = items.inslot(ab)
  if inv and inv.class(true) == "weapon" then return end

  for p=1,5 do
    if priorities_ab[p] > ab then
      items.swap_slots(priorities_ab[p], ab)
      priorities_ab[p] = -1
      return
    end
  end
end

local function cleanup_weapon_slots()
  generate_priorities()
  cleanup_ab(0)
  cleanup_ab(1)
  cleanup_w()
end





local do_cleanup_weapon_slots = false

---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_assign_invletter_weapon_slots(it)
  if it.class(true) ~= "weapon" and it.class(true) ~= "magical staff" then return end
  
  for i=0,2 do
    local slot
    if i==2 then slot = items.letter_to_index("w")
    else slot = i
    end
    
    local inv = items.inslot(slot)
    if not inv then return slot end
    if inv.class(true) ~= "weapon" and inv.class(true) ~= "magical staff" then
      items.swap_slots(slot, get_first_empty_slot())
      return slot
    end
  end
end



function c_message_weapon_slots(text, channel)
  if channel ~= "plain" then return end
  if not text:find("You drop ") then return end
  do_cleanup_weapon_slots = true
end



function ready_weapon_slots()
  if do_cleanup_weapon_slots then
    cleanup_weapon_slots()
    do_cleanup_weapon_slots = false
  end
end

}

########features/exclude-dropped.rc########

{
-- Add autopickup exclusion for any jewellery/missile/evocable item that is dropped
-- Exclusion is removed when you pick the item back up

-------------------------
---- Persistant data ----
-------------------------
if not dropped_item_exclusions or you.turns() == 0 then
  dropped_item_exclusions = ""
end

local function persist_dropped_item_exclusions()
  return "dropped_item_exclusions = \""..dropped_item_exclusions.."\""..string.char(10)
end

if not added_exclude_dropped_hooks then
  table.insert(chk_lua_save, persist_dropped_item_exclusions)
  added_exclude_dropped_hooks = true
end


local function get_jewellery_name(text)
  local idx  = text:find("ring of ")
  if not idx then idx = text:find("amulet of ") end
  if not idx then return end
  
  text = text:gsub(" {.*}", "")
  text = text:gsub("[.]", "")
  return text:sub(idx,#text)
end

local all_missiles = { " stone", "poisoned dart", "curare", "atropa", "datura", "boomerang", "javelin" }
local function get_missile_name(text)
  for _, item_name in ipairs(all_missiles) do
    if text:find(item_name) then
      if item_name == "boomerang" or item_name == "javelin" then
        if text:find("silver") then
          item_name = "silver "..item_name
        elseif text:find("dispersal") then
          item_name = item_name.."s? of dispersal"
        else
          item_name = "(?<!silver )"..item_name.."(?!(s? of dispersal))"
        end
      end
      
      return item_name
    end
  end
end

local all_misc = { "phial of floods", "lightning rod", "tin of tremorstones", 
      "condenser vane", "box of beasts", "phantom mirror", "piece from Xom's chessboard" }
local function get_misc_name(text)
  for _, item_name in ipairs(all_misc) do
    if text:find(item_name) then return item_name end
  end
end



------------------------------------------
------------------ Hook ------------------
------------------------------------------

function c_message_exclude_dropped(text, channel)
  if channel ~= "plain" then return end
  
  local exclude
  if text:find("You drop ") then exclude = true
  elseif text:find(" %- ") then exclude = false
  else return
  end

  local item_name = get_jewellery_name(text)
  if not item_name then item_name = get_missile_name(text) end
  if not item_name then item_name = get_misc_name(text) end
  if not item_name then return end

  if exclude then
    crawl.setopt("autopickup_exceptions ^= >"..item_name)
    if dropped_item_exclusions ~= "" then dropped_item_exclusions = dropped_item_exclusions.."," end
  else
    crawl.setopt("autopickup_exceptions -= >"..item_name)
    -- Remove persistant exclusion (try 3 times to make sure we capture comma)
    dropped_item_exclusions = dropped_item_exclusions:gsub(",>"..item_name, "")
    dropped_item_exclusions = dropped_item_exclusions:gsub(">"..item_name..",", "")
    dropped_item_exclusions = dropped_item_exclusions:gsub(">"..item_name, "")
  end
end
if dropped_item_exclusions ~= "" then crawl.setopt("autopickup_exceptions ^= "..dropped_item_exclusions) end

}

########features/safe-consumables.rc########

###############################
####### Auto-inscribe #########
# Unidentified consumables
#autoinscribe += potions?(?!.*of ):!q
#autoinscribe += scrolls?(?!.*of ):!r

# Add a warning for everything that doesn't have one built-in
autoinscribe += potions? of(?!.*(attraction|lignification|mutation)):!q
autoinscribe += scrolls? of(butterflies|fear|fog|magic mapping|posion|silence|summoning|teleportation|torment|vulnerability):!r


{
--------------------------------------------
---- Protective consumable inscriptions ----
--------------------------------------------
-- Initialize to true to fix inscriptions on init (starting items don't get default inscriptions)
local no_inscriptions = {"acquirement", "amnesia", "blinking", "brand weapon", "enchant armour", "enchant weapon", 
                         "identify", "immolation", "noise", "poison", "vulnerability", "attraction", "lignification", "mutation" }

local function fix_inscriptions()
  -- Remove the default "!r" and "!q" inscriptions after identify
  local keystring = ""
  for it in iter.invent_iterator:new(items.inventory()) do    
    if it.fully_identified then
      local it_class = it.class(true)
      if it_class == "potion" or it_class == "scroll" then
        local qualname = it.name("qual")
        local st, _ = it.subtype()
        
        if util.contains(no_inscriptions, st) then
          if it.inscription:find("%!r") then it.inscribe(it.inscription:gsub("%!r", ""), false) end
          if it.inscription:find("%!q") then it.inscribe(it.inscription:gsub("%!q", ""), false) end
        elseif it_class == "scroll" and not util.contains(no_inscriptions, st) and not qualname:find("!r") then
          it.inscribe("!r")
        elseif it_class == "potion" and not util.contains(no_inscriptions, st) and not qualname:find("!q") then
          it.inscribe("!q")
        end
      end
    end
  end
end


local do_fix_inscriptions = true

---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function ready_safe_consumables()
  if do_fix_inscriptions then
    fix_inscriptions()
    do_fix_inscriptions = false
  end
end


function c_message_safe_consumables(text, channel)
  if channel ~= "plain" then return end
  local triggers = { "Thank you for shopping at", "s a scroll of ", "s a potion of ", "read the scroll of identify" }
  for _, v in ipairs(triggers) do
    if text:find(v) then
      fix_inscriptions()
      do_fix_inscriptions = true
      return
    end
  end
end

}

########features/drop-inferior.rc########

-- Auto-drop items that are strictly worse than another
-- On item pickup, inscribes inferior items with "~drop"
drop_filter += ~drop

{
------------------------------------------
------------------ Hook ------------------
------------------------------------------
function c_assign_invletter_drop_inferior(it)
  -- Skip brands that are potentially harmful
  local it_ego = it.ego()
  if it_ego == "distortion" or it_ego == "chaos" or it_ego == "infusion" then return end
  
  local it_class = it.class(true)
  if it_class ~= "weapon" and it_class ~= "armour" then return end
  
  local risky_artefact = false
  if it.artefact then
    local qualname = it.name("qual")
    if qualname:find("%-") or qualname:find("Harm") or qualname:find("Infuse") then
      risky_artefact = true
    end
  end

  if risky_artefact then return end

  local st = it.subtype()
  local basename = it.name("base")

  for inv in iter.invent_iterator:new(items.inventory()) do
    local item_match = false
    if inv.subtype() == st then
      if st == "body" then
        if inv.encumbrance >= it.encumbrance then item_match = true end
      else
        if inv.name("base") == basename then item_match = true end
      end
    end

    if not inv.artefact and item_match and (not has_ego(inv) or inv.ego() == it.ego()) then
      if it_class == "weapon" then
        if inv.plus <= it.plus then inv.inscribe("~drop") end
      else
        if inv.ac <= it.ac then inv.inscribe("~drop") end
      end
    end
  end
end


function c_assign_invletter_exclude_dropped(it)
  it.inscribe(it.inscription:gsub("~drop", ""), false)
end
}

########features/runrest-features.rc########

{
--------------------------------
---- Fully rest off effects ----
--------------------------------
crawl.setopt("runrest_ignore_message += recovery:.*")
crawl.setopt("runrest_ignore_message += duration:.*")

local function fully_recovered()
  local status_wait = { "on berserk cooldown", "short of breath", "corroded", "vulnerable"}
  for _, s in ipairs(status_wait) do
    if you.status(s) then return false end
  end
  return true
end

local waiting_for_recovery = false
local explore_after_recovery = false

-- Attach full recovery to auto-explore
function explore_full_recovery()
  if not fully_recovered() then
    explore_after_recovery = true
    crawl.do_commands({"CMD_REST"})
  elseif you.status("slowed") then
    if not (you.strength() <=0 or you.intelligence() <= 0 or you.dexterity() <=0) then
       explore_after_recovery = true
       crawl.do_commands({"CMD_REST"})
    else
      crawl.do_commands({"CMD_EXPLORE"})
    end
  else
    crawl.do_commands({"CMD_EXPLORE"})
  end
end
crawl.setopt("macros += M o ===explore_full_recovery")

-------------------------------------
---- Hooks (All functions below) ----
-------------------------------------

--------------------------------
---- rest off effects cont. ----
--------------------------------
function ch_stop_running_full_recovery(kind)
  if kind == "run" and not fully_recovered() then
    waiting_for_recovery = true
    crawl.setopt("message_colour += mute:You start waiting.")
  end
end

function c_message_fully_recover(text, channel)
--if text:find("contamination") then crawl.mpr(text) crawl.mpr(channel) end
  if text:find("You start waiting.") then
    if not fully_recovered() then
      waiting_for_recovery = true
      crawl.setopt("message_colour += mute:You start waiting.")
    end
  elseif waiting_for_recovery then
    you.stop_activity()
  end
end

function ready_fully_recover()
  if waiting_for_recovery then
    if fully_recovered() then
      you.stop_activity()
      crawl.setopt("message_colour -= mute:You start waiting.")
      waiting_for_recovery = false
      crawl.mpr("Fully recovered.")
      
      if explore_after_recovery then
        crawl.sendkeys("o")
        explore_after_recovery = false
      end
    else
      crawl.do_commands({"CMD_WAIT"})
    end
  end
end

--------------------------------------------------------------------
---- End Fully rest off effects (Hooks for other features cont. ----
--------------------------------------------------------------------

----------------------
---- Ignore altars ----
-----------------------
local stop_on_altars = true

function ready_ignore_altars()
  if stop_on_altars and (you.god() ~= "No God" or you.branch() == "Temple") then
    stop_on_altars = false
    crawl.setopt("explore_stop -= altars")
  elseif not stop_on_altars and you.god() == "No God" and you.branch() ~= "Temple" then
    stop_on_altars = true
    crawl.setopt("explore_stop += altars")
  end
end


-----------------------------------------------
---- Search altars in temple after explore ----
-----------------------------------------------
function c_message_search_altars_in_temple(text, channel)
  if you.branch() == "Temple" and text:find("explor") then
    crawl.sendkeys({ 6, "altar\r" })
  end
end


-----------------------------
---- Ignore exit portals ----
-----------------------------
local ignore_exit_brances = { "Bailey", "Bazaar", "Ice Cave", "Ossuary", "Sewer", "Trove", "Volcano", "Ziggurat" }
local stop_on_portals = true

function ready_ignore_exits()
  local branch = you.branch()
  if stop_on_portals and util.contains(ignore_exit_brances, branch) then
    stop_on_portals = false
    crawl.setopt("explore_stop -= portals")
  elseif not stop_on_portals and not util.contains(ignore_exit_brances, branch) then
    stop_on_portals = true
    crawl.setopt("explore_stop += portals")
  end
end

}

########features/mute-swaps.rc########

{
-- When an item is moved to its assigned slot, mute the messages for the item that was previously in that slot
-- If we cared what slot the item was in, it'd already be assigned somewhere
-- This mostly matters when reading scroll of ID, where 5-6 lines of inventory items can be confusing

--------------
---- Util ----
--------------
local function cleanup_message(text)
  local tags_removed = {}
  
  local keep_going = true
  while keep_going do
    local opening = text:find("<")
    local closing = text:find(">")    
    
    if opening and closing and opening < closing then
      local new_text = ""
      if opening > 1 then new_text = text:sub(1, opening-1) end
      if closing < #text then new_text = new_text..text:sub(closing+1, #text) end
      text = new_text
    else
      keep_going = false
    end
  end
  
  text = text:gsub("\n", "")
  return text
end

muted_items = {}

-- Must define this separate from ready() if we want to call it from c_message_mute_swaps as well
local function unmute_items()
  for _, v in ipairs(muted_items) do
    crawl.setopt("message_colour -= mute: - "..v)
  end
  muted_items = {}
end
---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function ready_mute_swaps()
  unmute_items()
end

local last_pickup_turn = -1
function c_assign_invletter_mute_swaps(it)
  -- this causes an unmute command on the message
  -- we can't unmute in time from this hook
  if you.turns() == last_pickup_turn then
    crawl.mpr("")
  else
    last_pickup_turn = you.turns()
  end
end

function c_message_mute_swaps(text, channel)
  -- Mute subsequent item re-assignments in a single turn, for everything after the first item.
  -- Multiple slots for the same item will still be shown
  if channel == "plain" then 
    text = cleanup_message(text)
    if text:sub(2,4) == " - " then
      local item = text:sub(5, #text)
      local mute_str = "(?!.*("..item.."))"
      table.insert(muted_items, mute_str)
      crawl.setopt("message_colour ^= mute: - "..mute_str)
      return
    end
  end
  
  unmute_items()
end
}

########features/after-shaft.rc########

{
------------------------------------
---- Stop on stairs after shaft ----
------------------------------------
if not shaft_depth or you.turns() == 0 then
  shaft_depth = 0
  shaft_branch = "NA"
end

function persist_shaft_values()
  local cmd = "shaft_depth = "..shaft_depth..string.char(10) .."shaft_branch = \""..shaft_branch.."\""..string.char(10)
  return cmd
end

if not added_shaft_stairs_hook then
  table.insert(chk_lua_save, persist_shaft_values)
  added_shaft_stairs_hook = true
end


---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_message_after_shaft(text, channel)
  if shaft_depth ~= 0 then return end
  if text:find("fall into a shaft") then
    shaft_depth = you.depth()
    shaft_branch = you.branch()
    crawl.setopt("explore_stop += stairs")
  end
end

function ready_after_shaft()
  if shaft_depth ~= 0 then
    if you.depth() == shaft_depth and you.branch() == shaft_branch then
      crawl.setopt("explore_stop -= stairs")
      shaft_depth = 0
      shaft_branch = "NA"
    end
  end
end

}


####################################################################
######################## Lua Hook Functions ########################
####################################################################
{
----------------------------------
---------- c_message() -----------
----------------------------------
function c_message(text, channel)

  if c_message_remind_identify then c_message_remind_identify(text, channel) end
  if c_message_weapon_slots then c_message_weapon_slots(text, channel) end
  if c_message_exclude_dropped then c_message_exclude_dropped(text, channel) end
  if c_message_safe_consumables then c_message_safe_consumables(text, channel) end
  if c_message_search_altars_in_temple then c_message_search_altars_in_temple(text, channel) end
  if c_message_fully_recover then c_message_fully_recover(text, channel) end
  if c_message_mute_swaps then c_message_mute_swaps(text, channel) end
  if c_message_after_shaft then c_message_after_shaft(text, channel) end
  if c_message_inscribe_dps then c_message_inscribe_dps(text, channel) end

end


-------------------------------------------
---------- c_assign_inv_letter() ----------
-------------------------------------------
function c_assign_invletter(it)
  -- Calls with no return values; just triggering on new item pickup
  if c_assign_invletter_item_alerts then c_assign_invletter_item_alerts(it) end
  if c_assign_invletter_remind_identify then c_assign_invletter_remind_identify(it) end
  if c_assign_invletter_exclude_dropped then c_assign_invletter_exclude_dropped(it) end
  if c_assign_invletter_drop_inferior then c_assign_invletter_drop_inferior(it) end
  if c_assign_invletter_mute_swaps then c_assign_invletter_mute_swaps(it) end
    
  -- Calls with possible return values
  local ret_val = nil
  if c_assign_invletter_weapon_slots then ret_val = c_assign_invletter_weapon_slots(it) end
  if ret_val then return ret_val end
end


---------------------------
---- ch_stop_running() ----
---------------------------
function ch_stop_running(kind)
  if ch_stop_running_full_recovery then ch_stop_running_full_recovery(kind) end
end
}

{
-----------------------------
---- Begin char_defaults ----
-----------------------------

-- See README.md for documentation.

weapon_skills = {"Unarmed Combat", "Short Blades", "Long Blades", "Axes",
                 "Maces & Flails", "Polearms", "Staves"}
ranged_skills = {"Throwing", "Bows", "Crossbows", "Slings"}
other_skills = {"Fighting", "Armour", "Dodging",
                "Shields", "Spellcasting", "Conjurations", "Hexes", "Charms",
                "Summonings", "Necromancy", "Translocations", "Transmutations",
                "Fire Magic", "Ice Magic", "Air Magic", "Earth Magic",
                "Poison Magic", "Invocations", "Evocations","Stealth"}
skill_glyphs = { [1] = "+", [2] = "*" }
chdat = nil
char_combo = you.race() .. you.class()
loaded_attempted = false

-- Wrapper of crawl.mpr() that prints text in white by default.
if not mpr then
  mpr = function (msg, color)
    if not color then
      color = "white"
    end
    crawl.mpr("<" .. color .. ">" .. msg .. "</" .. color .. ">")
  end
end

function skill_message(prefix, skill, skill_type, value)
  local msg = ""
  if prefix then
    msg = prefix .. ";"
  end
  if skill_type then
    msg = msg .. skill_type .. "(" .. skill .. "):" .. value
  else
    msg = msg .. skill .. ":" .. value
  end
  return msg
end

function save_char_defaults(quiet)
  if you.class() == "Wanderer" then
    return
  end
  if not c_persist.char_defaults then
    c_persist.char_defaults = { }
  end
  c_persist.char_defaults[char_combo] = { }
  chdat = c_persist.char_defaults[char_combo]
  local msg = nil
  local have_weapon = false
  for _,sk in ipairs(weapon_skills) do
    if you.train_skill(sk) > 0 then
      chdat["Weapon"] = you.train_skill(sk)
      msg = skill_message(nil, sk, "Weapon",
                          skill_glyphs[chdat["Weapon"]])
      have_weapon = true
      break
    end
  end
  if not have_weapon then
    chdat["Weapon"] = nil
  end
  local have_ranged = false
  for _,sk in ipairs(ranged_skills) do
    if you.train_skill(sk) > 0 then
      chdat["Ranged"] = you.train_skill(sk)
      msg = skill_message(msg, sk, "Ranged",
                          skill_glyphs[chdat["Ranged"]])
      have_ranged = true
      break
    end
  end
  if not have_ranged then
    chdat["Ranged"] = nil
  end
  for _,sk in ipairs(other_skills) do
    if you.train_skill(sk) > 0 then
      chdat[sk] = you.train_skill(sk)
      msg = skill_message(msg, sk, nil, skill_glyphs[chdat[sk]])
    else
      chdat[sk] = nil
    end
  end
  if not quiet then
    mpr("Saved default for " .. char_combo .. ": " .. msg)
  end
end

function have_defaults()
  return  you.class() ~= "Wanderer"
    and c_persist.char_defaults ~= nil
    and c_persist.char_defaults[char_combo] ~= nil
end

function load_char_defaults(quiet)
  if not have_defaults() then
    return
  end
  local msg = nil
  local found_weapon = false
  chdat = c_persist.char_defaults[char_combo]
  for _,sk in ipairs(weapon_skills) do
    if you.base_skill(sk) > 0 and chdat["Weapon"] then
      you.train_skill(sk, chdat["Weapon"])
      msg = skill_message(msg, sk, "Weapon",
                          skill_glyphs[chdat["Weapon"]])
      found_weapon = true
    else
      you.train_skill(sk, 0)
    end
  end
  if chdat["Weapon"] and not found_weapon then
    you.train_skill("Unarmed Combat", chdat["Weapon"])
    msg = skill_message(msg, "Unarmed Combat", "Weapon",
                        skill_glyphs[chdat["Weapon"]])
  end
  local found_ranged = false
  for _,sk in ipairs(ranged_skills) do
    if you.base_skill(sk) > 0 and chdat["Ranged"] then
      you.train_skill(sk, chdat["Ranged"])
      msg = skill_message(msg, sk, "Ranged",
                          skill_glyphs[chdat["Ranged"]])
      found_ranged = true
    else
      you.train_skill(sk, 0)
    end
  end
  if chdat["Ranged"] and not found_ranged then
    you.train_skill("Throwing", chdat["Ranged"])
    msg = skill_message(msg, "Throwing", "Ranged",
                        skill_glyphs[chdat["Ranged"]])
  end
  for _,sk in ipairs(other_skills) do
    if chdat[sk] then
      you.train_skill(sk, chdat[sk])
      msg = skill_message(msg, sk, nil, skill_glyphs[chdat[sk]])
    else
      you.train_skill(sk, 0)
    end
  end
  if not quiet and msg ~= "" then
    mpr("Loaded default for " .. char_combo .. ": " .. msg)
  end
end

function char_defaults(quiet)
  if you.turns() ~= 0 then
    return
  end

  if not load_attempted then
    load_char_defaults(quiet)
    load_attempted = true

    -- Open the skill menu if we don't have settings to load.
    if not have_defaults() then
      crawl.sendkeys("m")
    end
  end
end

---------------------------
---- End char_defaults ----
---------------------------
}

{
function enhanced_explore()
   if you.status():find("contam") or you.status("berserking") or you.status("on berserk cooldown") or you.status("short of breath") or you.status("corroded") or you.status("vulnerable") or you.status("poisoned") then
      crawl.do_commands({"CMD_REST"})
   elseif you.status("slowed") then
      if not (you.strength() <=0 or you.intelligence() <= 0 or you.dexterity() <=0) then
         crawl.do_commands({"CMD_REST"})
      else
        crawl.do_commands({"CMD_EXPLORE"})
      end
   else
      crawl.do_commands({"CMD_EXPLORE"})
   end
end
}
# Ask HilariousDeathArtist to fix things

# To use this you must add have a call to AnnounceDamage() in the ready() function like below:
# This is important if you override this ready() function
# <
#  function ready()
#    AnnounceDamage()
#  end
# >

###############
# Damage Calc #
###############
{
  local previous_hp = 0
  local previous_mp = 0
  local previous_form = ""
  local was_berserk_last_turn = false

  function AnnounceDamage()
    local current_hp, max_hp = you.hp()
    local current_mp, max_mp = you.mp()
    --Things that increase hp/mp temporarily really mess with this
    local current_form = you.transform()
    local you_are_berserk = you.berserk()
    local max_hp_increased = false
    local max_hp_decreased = false

    if (current_form ~= previous_form) then
      if (previous_form:find("dragon") or
          previous_form:find("statue") or
          previous_form:find("tree") or
          previous_form:find("ice")) then
        max_hp_decreased = true
      elseif (current_form:find("dragon") or
          current_form:find("statue") or
          current_form:find("tree") or
          current_form:find("ice")) then
        max_hp_increased = true
      end
    end
    if (was_berserk_last_turn and not you_are_berserk) then
      max_hp_decreased = true
    elseif (you_are_berserk and not was_berserk_last_turn) then
      max_hp_increased = true
    end

    --crawl.mpr(string.format("previous_form is: %s", previous_form))
    --crawl.mpr(string.format("current_form is: %s", current_form))
    --crawl.mpr(string.format("max_hp_increased is: %s", max_hp_increased and "True" or "False"))
    --crawl.mpr(string.format("max_hp_decreased is: %s", max_hp_decreased and "True" or "False"))

    --crawl.mpr(string:format("you_are_berserk is: %s", you_are_berserk and "True" or "False"))
    --crawl.mpr(string:format("was_berserk_last_turn is: %s", was_berserk_last_turn and "True" or "False"))


    --Skips message on initializing game
    if previous_hp > 0 then
      local hp_difference = previous_hp - current_hp
      local mp_difference = previous_mp - current_mp

      if max_hp_increased or max_hp_decreased then
        if max_hp_increased then
          crawl.mpr("<green>You now have " .. current_hp .. "/" .. max_hp .. " hp.</green>")
        else
          crawl.mpr("<yellow>You now have " .. current_hp .. "/" .. max_hp .. " hp.</yellow>")
        end
      else
        --On losing health
        if (current_hp < previous_hp) then
          if current_hp <= (max_hp * 0.30) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><lightred> and have " .. current_hp .. "/" .. max_hp .. " hp.</lightred>")
          elseif current_hp <= (max_hp * 0.50) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage, and have " .. current_hp .. "/" .. max_hp .. " hp.</red>")
          elseif current_hp <= (max_hp *  0.70) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><yellow> and have " .. current_hp .. "/" .. max_hp .. " hp.</yellow>")
          elseif current_hp <= (max_hp * 0.90) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><lightgrey> and have " .. current_hp .. "/" .. max_hp .. " hp.</lightgrey>")
          else
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><green> and have " .. current_hp .. "/" .. max_hp .. " hp.</green>")
          end
          if hp_difference > (max_hp * 0.20) then
            crawl.mpr("<lightred>MASSIVE DAMAGE!!</lightred>")
          end
        end

        --On gaining more than 1 health
        if (current_hp > previous_hp) then
          --Removes the negative sign
          local health_inturn = (0 - hp_difference)
          if (health_inturn > 1) and not (current_hp == max_hp) then
            if current_hp <= (max_hp * 0.30) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><lightred> and now have " .. current_hp .. "/" .. max_hp .. " hp.</lightred>")
            elseif current_hp <= (max_hp * 0.50) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><red> and now have " .. current_hp .. "/" .. max_hp .. " hp.</red>")
            elseif current_hp <= (max_hp *  0.70) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><yellow> and now have " .. current_hp .. "/" .. max_hp .. " hp.</yellow>")
            elseif current_hp <= (max_hp * 0.90) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><lightgrey> and now have " .. current_hp .. "/" .. max_hp .. " hp.</lightgrey>")
            else
              crawl.mpr("<green>You regained " .. health_inturn .. " hp, and now have " .. current_hp .. "/" .. max_hp .. " hp.</green>")
            end
          end
          if (current_hp == max_hp) then
            crawl.mpr("<green>Health restored: " .. current_hp .. "</green>")
          end
        end

        --On gaining more than 1 magic
        if (current_mp > previous_mp) then
          --Removes the negative sign
          local mp_inturn = (0 - mp_difference)
          if (mp_inturn > 1) and not (current_mp == max_mp) then
            if current_mp < (max_mp * 0.25) then
              crawl.mpr("<lightcyan>You regained " .. mp_inturn .. " mp,</lightcyan><red> and now have " .. current_mp .. "/" .. max_mp .. " mp.</red>")
            elseif current_mp < (max_mp * 0.50) then
              crawl.mpr("<lightcyan>You regained " .. mp_inturn .. " mp,</lightcyan><yellow> and now have " .. current_mp .. "/" .. max_mp .. " mp.</yellow>")
            else
              crawl.mpr("<lightcyan>You regained " .. mp_inturn .. " mp,</lightcyan><green> and now have " .. current_mp .. "/" .. max_mp .. " mp.</green>")
            end
          end
          if (current_mp == max_mp) then
            crawl.mpr("<lightcyan>MP restored: " .. current_mp .. "</lightcyan>")
          end
        end

        --On losing magic
        if current_mp < previous_mp then
          if current_mp <= (max_mp / 5) then
            crawl.mpr("<lightcyan>You now have </lightcyan><red>" .. current_mp .. "/" ..max_mp .." mp.</red>")
          elseif current_mp <= (max_mp / 2) then
            crawl.mpr("<lightcyan>You now have </lightcyan><yellow>" .. current_mp .. "/" ..max_mp .." mp.</yellow>")
          else
            crawl.mpr("<lightcyan>You now have </lightcyan><green>" .. current_mp .. "/" ..max_mp .." mp.</green>")
          end
        end
      end
    end

    --Set previous hp/mp and form at end of turn
    previous_hp = current_hp
    previous_mp = current_mp
    previous_form = current_form
    was_berserk_last_turn = you_are_berserk
  end
}



# The ready() function  is needed for code that has to process each turn or UI
# action.
{
function ready()

  if char_defaults then char_defaults() end

  if AnnounceDamage then AnnounceDamage() end


  if ready_force_mores then ready_force_mores() end
  if ready_dynamic_options then ready_dynamic_options() end
  if ready_weapon_slots then ready_weapon_slots() end
  if ready_safe_consumables then ready_safe_consumables() end
  if ready_mute_swaps then ready_mute_swaps() end
  if ready_ignore_altars then ready_ignore_altars() end
  if ready_ignore_exits then ready_ignore_exits() end
  if ready_after_shaft then ready_after_shaft() end
  if ready_fully_recover then ready_fully_recover() end

  
  if not next_skill_level then
    next_skill_level = 3
  end
  
  if you.xl() >= next_skill_level then
    next_skill_level = ((you.xl()/3)*3)+3
    crawl.sendkeys("m")
  end



end
}

#############
### Debug ###
#############

fsim_rounds = 10000