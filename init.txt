# Crawl Init file
# See the README for further details:
# https://github.com/gammafunk/dcss-rc/blob/master/README.md

# NOTE: This RC has things enabled only for my username. If you're just
# including this RC file in your own with
#
# include = gammafunk.rc
#
# then you don't have to worry about these. However if you're copy all or parts
# of gammafunk.rc directly into your own RC file, look for any sections
# conditioned on my username and follow notes in the comments for removing or
# modifying them.


###############
### Display ###
###############

#"black", "blue", "green", "cyan", "red", "magenta", "brown",
#  "lightgrey", "darkgrey", "lightblue", "lightgreen", "lightcyan",
#  "lightred", "lightmagenta", "yellow", "white"
# black
# blue - Dangerous
# green - Generally good
# cyan - Conditional
# red - Extremely bad
# magenta - magic bias?
# brown
# lightgrey - Default
# darkgrey - worthless
# lightblue
# lightgreen
# lightcyan
# lightred - very good
# lightmagenta
# yellow
# white - Epic level.


view_delay = 300
hp_colour = 100:green, 99:lightgray, 75:yellow, 50:lightred, 25:red
mp_colour = 100:green, 99:lightgray, 75:yellow, 50:lightred, 25:red
hp_warning = 50
mp_warning = 50

# enemy_hp_colour = green green brown brown red magenta

#enemy_hp_colour = green lightgreen yellow lightred red magenta
#monster_list_colour =
#monster_list_colour += friendly:green,neutral:brown
#monster_list_colour += good_neutral:brown,strict_neutral:brown
#monster_list_colour += trivial:darkgrey,easy:lightgrey
#monster_list_colour += tough:yellow,nasty:lightred

###############
### Console ###
###############

# Enable use of darkgrey.
bold_brightens_foreground=true

# Monster List
mlist_allow_alternate_layout = true
monster_item_view_coordinates = true

equip_bar = true

## For item_glyph, subsequent matches override previous ones.
item := item_glyph

## Reasonable defaults
item += potion:lightgrey
item += scroll:lightgrey
item += wand:lightgrey
item += dangerous_item:blue
item += useless_item:darkgrey

### Potions ###

item += potions? of.*berserk:brown
item += potions? of.*mutation:lightcyan

item += potions? of.*(lignification|ambrosia):blue
item += potions? of.*haste:green
item += potions? of.*might:yellow
item += potions? of.*resistance:lightgreen

item += potions? of.*heal wounds:white
item += potions? of.*curing:lightblue
item += potions? of.*cancellation:cyan

item += potions? of.*brilliance:magenta
item += potions? of.*magic:lightmagenta

item += potions? of.*experience:lightred


item += potions? of.*(flight|invisibility|attraction):lightgreen


### Scrolls ###

: if you.race() == "Vampire" or you.race() == "Mummy"
:  or you.race() == "Ghoul" then
  item += scroll.*torment:brown
: else
  item += scroll.*torment:darkgrey
: end

item += scroll.*poison:brown

item += scroll.*acquirement:lightred
item += scroll.*(summoning):yellow
item += scroll.*identify:white
item += scroll.*magic mapping:lightcyan

item += scroll.*(silence|vulnerability|immolation):blue
item += scroll.*(fog|butterflies|teleport):green
item += scroll.*(fear|blink):lightgreen
item += scroll.*(enchant|brand weapon):lightmagenta

### Wands ###

# Single target piercing.
item += wand of.*(acid|light|quicksilver):yellow

item += wand of.*flame:lightgrey

item += wand of.*digging:green

# Single-turn AOE
item += wand of.*(iceblast|roots):cyan

# MR-checking
item += wand of.*(mindburst|polymorph):magenta
item += wand of.*(paralysis|charming):lightmagenta

### General Identification ###
item += manual of:cyan
item += manual:lightcyan
item += unidentified.*book:lightmagenta
item += unidentified.*(potion|scroll|jewellery|wand|magical staff).*:lightblue

item += (identified|known).*(jewellery|magical staff):brown
item += identified.*spellbook:magenta

### Jewellery ###
item += .*ring of (dexterity|strength|intelligence):lightcyan
item += .*ring of (evasion|protection|slaying):lightmagenta
item += .*ring of (protection from|resist corrosion|poison resistance|positive energy|willpower):green
item += .*ring of (wizardry|magical power):magenta
item += .*ring of (fire|ice):cyan

item += .*amulet of (the acrobat|guardian spirit|reflection):lightgreen
item += .*amulet of.*regeneration:lightred
item += .*amulet of faith:cyan

item += identified.*artefact.*(jewellery):white
item += unidentified.*artefact.*(jewellery).*:lightmagenta


# Want this to override anything above
item += useless:darkgrey
# Only mark these types when forbidden; for other types it looks odd.
item += forbidden.*(potion|scroll):red

mons := mon_glyph
# Monsters that can be easy to miss
mons ^= * : ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚ÂœÃƒÂ‚Ã‚Â±
mons ^= dancing weapon : cyan {
mons ^= spectral weapon : lightcyan {
# Classed Demonspawn
mon += blood saint:9
mon += warmonger:9
mon += corrupter:9
mon += black sun:9

# Wall glyphs; requires a font and terminal that can render these.
feature += crystal wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Â‘}
feature += stone wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Â’}
feature += metal wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Â“}
feature += unnaturally hard rock wall {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚Â–ÃƒÂ‚Ã‚Âˆ}

feature += altar {ÃƒÂƒÃ‚Â¢ÃƒÂ‚Ã‚ÂšÃƒÂ‚Ã‚Â‘}

#############
### Tiles ###
#############

tile_window_width = 1300
tile_window_height = 700
tile_full_screen = false
tile_map_pixels = 3


###################
### Menu Colors ###
###################

# These should match the item_glyph colours exactly when possible.
# For menu_colour, the first match ignores subsequent matches.
menu := menu_colour
menu =

# Many of the entries below come from dat/defaults/menu_colours.txt,
# which we have to duplicate here since we want only some of the
# entries from that file.
menu += notes:white:Reached XP level

### General Inventory###
# Items currently not affecting you.
menu += darkgrey:(melded)
# Items disliked by your god.
menu += red:forbidden
# Useless items, comes here to override artefacts etc.
menu += darkgrey:.*useless.*
# Handle cursed and equipped items early to override other colour settings.
menu += lightred:.*equipped.* cursed
menu += red: (a|the) cursed
menu += inventory:lightgreen:.*equipped.*
# Colouring of autoinscribed god gifts
menu += pickup:lightred:god gift
# Highlight (partly) selected items
menu += inventory:white:\w \+\s
menu += inventory:white:\w \#\s

### Potions ###


menu += brown:potions? of.*berserk
menu += lightcyan:potions? of.*mutation

menu += blue:potions? of.*(lignification|ambrosia)
menu += green:potions? of.*haste
menu += yellow:potions? of.*might
menu += lightgreen:potions? of.*resistance

menu += white:potions? of.*heal wounds
menu += lightblue:potions? of.*curing
menu += cyan:potions? of.*cancellation

menu += magenta:potions? of.*brilliance
menu += lightmagenta:potions? of.*magic

menu += lightred:potions? of.*experience

### Scrolls ###

: if you.race() == "Vampire" or you.race() == "Mummy"
:  or you.race() == "Ghoul" then
  menu += brown:scroll.*torment
: else
  menu += darkgrey:scroll.*torment
: end
menu += brown:scroll.*poison

menu += lightred:scroll.*acquirement
menu += yellow:scroll.*(summoning)
menu += white:scroll.*identify
menu += lightcyan:scroll.*magic mapping

menu += blue:scroll.*(silence|vulnerability|immolation)
menu += green:scroll.*(fog|butterflies|teleport)
menu += lightgreen:scroll.*(fear|blink)
menu += lightmagenta:scroll.*(enchant|brand weapon)

### Wands ###

# Single target piercing.
menu += yellow:wand of.*(acid|light|quicksilver)

menu += lightgrey:wand of.*flame

menu += green:wand of.*digging

# Explosion
menu += cyan:wand of.*(iceblast|roots)

# MR-checking
menu += magenta:wand of.*(mindburst|polymorph)
menu += lightmagenta:wand of.*(paralysis|charming)

### General identification ###

menu += cyan:manual of
menu += lightcyan:manual
menu += lightmagenta:unidentified.*artefact.*
menu += white:.*artefact.*
menu += lightblue:unidentified .*(potion|scroll|wand|jewellery|spellbook|rod|magical staff)

menu += inventory:lightgray:.*(book|jewellery|magical staff)
# Ego items
menu += lightblue:unidentified.*weapon.*(runed|glowing|enchanted)
menu += lightblue:unidentified.*armour.*(runed|glowing|embroidered|shiny|dyed)

### Jewllery ###


menu += magenta:


menu += lightcyan:.*ring of (dexterity|strength|intelligence)
menu += lightmagenta:.*ring of (evasion|protection|slaying)
menu += green:.*ring of (protection from|resist corrosion|poison resistance|positive energy|willpower)
menu += magenta:.*ring of (wizardry|magical power)
menu += cyan:.*ring of (fire|ice)

menu += lightgreen:.*amulet of (the acrobat|guardian spirit|reflection)
menu += lightred:.*amulet of.*regeneration
menu += cyan:.*amulet of faith

menu += white:identified.*artefact.*(jewellery)
menu += lightmagenta:unidentified.*artefact.*(jewellery).*


#################
### Interface ###
#################

autofight_stop = 65
hp_warning = 20
item_stack_summary_minimum = 8
default_manual_training = true
messages_at_top = true
equip_unequip = true

show_more = false
autofight_caught = true
sort_menus = true:equipped,art,ego,glowing,identified,basename,qualname,>qty
drop_filter += useless_item, forbidden
fire_order = silver javelin, javelin, silver boomerang, boomerang, curare-tipped dart, poisoned dart, stone



# Spam autofight is bad
autofight_warning = 250

delay_safe_poison = 10:5


# No movement on regular tab
bindkey = [^I] CMD_AUTOFIGHT_NOMOVE
# Move as normal on g.
bindkey = [g] CMD_AUTOFIGHT


#runrest_ignore_message ^= You feel.*sick


############################
### Travel & Exploration ###
############################

rest_wait_both = true
travel_delay = 1
explore_delay = 1
rest_delay = -1

show_travel_trail = true
explore_wall_bias = 4

travel_key_stop = false

explore_auto_rest = true

warn_hatches = true
travel_open_doors = true
# change to avoid if stealth rating above, say, 50.


explore_greedy_visit = artefacts,glowing_items,stacks
explore_stop = artefacts,altars,branches,portals,runed_doors,greedy_pickup_smart
explore_stop_pickup_ignore += scroll, potion, wand, stone, dart, boomerang, javelin

################
# Keybindings to override the vi movement keys.
# CMD_NO_CMD_DEFAULT results in "Unknown command."
# See docs/keybind.txt for other commands.
################

bindkey = [h] CMD_NO_CMD_DEFAULT
bindkey = [j] CMD_NO_CMD_DEFAULT
bindkey = [k] CMD_NO_CMD_DEFAULT
bindkey = [l] CMD_NO_CMD_DEFAULT
bindkey = [H] CMD_NO_CMD_DEFAULT
bindkey = [J] CMD_NO_CMD_DEFAULT
bindkey = [K] CMD_NO_CMD_DEFAULT
bindkey = [L] CMD_NO_CMD_DEFAULT
#bindkey = [^H] CMD_NO_CMD_DEFAULT
#bindkey = [^J] CMD_NO_CMD_DEFAULT
#bindkey = [^K] CMD_NO_CMD_DEFAULT
#bindkey = [^L] CMD_NO_CMD_DEFAULT
bindkey = [y] CMD_NO_CMD_DEFAULT
bindkey = [u] CMD_NO_CMD_DEFAULT
bindkey = [b] CMD_NO_CMD_DEFAULT
bindkey = [n] CMD_NO_CMD_DEFAULT
bindkey = [Y] CMD_NO_CMD_DEFAULT
bindkey = [U] CMD_NO_CMD_DEFAULT
bindkey = [B] CMD_NO_CMD_DEFAULT
bindkey = [N] CMD_NO_CMD_DEFAULT
#bindkey = [^Y] CMD_NO_CMD_DEFAULT
#bindkey = [^U] CMD_NO_CMD_DEFAULT
#bindkey = [^B] CMD_NO_CMD_DEFAULT
#bindkey = [^N] CMD_NO_CMD_DEFAULT


##################
### Autopickup ###
##################

# Add staves, rods, misc; note you can't use += with this option.
autopickup = $?!+=/}|

#All useful, at least early game.
#Its only later that you would want to just remove these.
ae := autopickup_exceptions
ae += <throwing net
ae += <javelin
ae += <dart
ae += <stone
ae += <boomerang

: if you.race() == "Troll" or you.race() == ogre then
	ae += <large rock
: end

ae += <curare-tipped dart

ae ^= <spellbook
autopickup_exceptions ^= <tin of tremorstones


# Exceptions
# I use immolation somewhat early on, and vulnerability is useful the entire
# game.
ae += <vulnerability|immolation
# Don't ever need a second stave
ae += staff of .*

#######################################
####### Autopickup exceptions #########
#######################################
autopickup_exceptions ^= <potions? of attraction, <potions? of lignification, <potions? of mutation
autopickup_exceptions ^= <scrolls? of immolation, <scrolls? of poison
autopickup_exceptions ^= >useless_item, <misc
# Exclude the 3rd copy of any ring
{
  add_autopickup_func(function (it, name)
    if it.class(true) ~= "jewellery" or it.artefact then return end
    local st = it.subtype()
    local found_first = false
    for inv in iter.invent_iterator:new(items.inventory()) do
      if inv.class(true) == "jewellery" and inv.subtype() == st then
        if found_first then return false end
        found_first = true
      end
    end
  end)
}

# Extra flashes

flash := flash_screen_message

flash += distortion
flash += MASSIVE DAMAGE

# Gifts
flash += Okawaru grants you armor
flash += Okawaru grants you a weapon
flash += Trog grants you a weapon

# Malmutator
flash += (?<!your )(Orb of Fire|Shining eye|Cacodemon|Neqoxec)

flash += Strange energies course through your body
# Contamination

  flash += You are contaminated with residual magic.
  flash += You are heavily infused with residual magic.
  flash += You are practically glowing with residual magic!
  flash += Your entire body has taken on an eerie glow!
  flash += You are engulfed in a nimbus of crackling magics!


# Summon Failure
flash += doesn't seem very happy

# Need a Summons turn hostile/are hostile
#


##########
# Macros #
##########

bindkey = [~] CMD_LUA_CONSOLE
macros += M [ ===load_char_defaults
macros += M ] ===save_char_defaults
macros += M o ===enhanced_explore

macros += M + .


# Replacing VI keys, so
# yughjkbn are free.
#
# I is blink
# o is self-enhancement
# z is starting blast
# x, s seem to be better attack spells.
# aside from that, hard to say.
# figure it out and setup some defaults.
# keep blink as is, or figure out how to add a confirmation. Or use a capital/Ctrl mod.
# That actually gives me 24 macro slots.
# Make defaults for swapping rings, maybe necklaces.

macros += M z z*
macros += M h Zh
macros += M j Zj
macros += M k Zk
macros += M l Zl
macros += M y Zy
macros += M u Zu
macros += M b Zb
macros += M n Zn


###########################
### Spell/Ability slots ###
###########################

ability_slot += Fly|flight:lF
ability_slot += Stop Flying:L
ability_slot += Breathe:t
ability_slot += Invisibility:iv
# Abilities prone to miskeys.
ability_slot += Blink:IB
ability_slot += Berserk:k
ability_slot += Corrupt:C
ability_slot += Enter the Abyss:E

# 4 letters from words of the spell name at (1) beginning, (2) end,
# of words in the spell, (3) anywhere from the spell name, or (4) from the
# names of the spell schools, in order of preference.

#spell_slot += Alistair's intoxication:aisn
#spell_slot += Apportation:anpt
#spell_slot += Airstrike:ae
#spell_slot += Agony:aygn
#spell_slot += Animate dead:adet
#spell_slot += Animate skeleton:asen
#spell_slot += Beastly appendage:baye
#spell_slot += Blade hands:bhes
#spell_slot += Blink:BKLN
#spell_slot += Bolt of magma:bmta
#spell_slot += Borgnjor's revivification:BRSN
#spell_slot += Borgnjor's vile clutch:bvch
#spell_slot += Call canine familiar:cflr
#spell_slot += Call imp:cilp
#spell_slot += Cause fear:cfer
#spell_slot += Controlled blink:cbdk
#spell_slot += Corona:carn
#spell_slot += Chain lightning:clng
#spell_slot += Confusing touch:ctgh
#spell_slot += Conjure flame:cfej
#spell_slot += Corpse rot:cret
#spell_slot += Dazzling Flash:dfgh
#spell_slot += Darkness:aed
#spell_slot += Death channel:dtcl
## Upper-case to prevent miskeys.
#spell_slot += Death's door:DROT
#spell_slot += Discord:DCSR
#spell_slot += Disjunction:iuoe
#spell_slot += Dispel undead:ndp
#spell_slot += Dispersal:iea
#spell_slot += Dragon form:dgrf
#spell_slot += Dragon's call:dcl
#spell_slot += Ensorcelled hibernation:ehnd
#spell_slot += Eringya's Toxic Bog:bteg
#spell_slot += Excruciating wounds:ewgx
#spell_slot += Fire storm:fsmt
#spell_slot += Fireball:flbr
#spell_slot += Foxfire:fxro
#spell_slot += Freezing cloud:fcgd
#spell_slot += Freeze:fezr
#spell_slot += Frozen Ramparts:frnt
#spell_slot += Fulminant prism:fpmt
#spell_slot += Gell's Gravitas:glvt
#spell_slot += Haunt:htna
#spell_slot += Ice form:crmf
#spell_slot += Ignition:ntg
#spell_slot += Iron shot:stnr
#spell_slot += Inner flame:frn
#spell_slot += Invisibility:iyvb
#spell_slot += Irradiate:ierd
#spell_slot += Iskenderun's battlesphere:ibne
#spell_slot += Leda's Liquefaction:lanq
#spell_slot += Lee's rapid deconstruction:ldr
#spell_slot += Lesser Beckoning:lbg
#spell_slot += Lehudib's crystal spear:lcsb
#spell_slot += Lightning bolt:lbgt
#spell_slot += Magic dart:mdtc
#spell_slot += Malign gateway:mgy
#spell_slot += Manifold Assault:madt
#spell_slot += Maxwell's Capacitive Coupling:mclp
#spell_slot += Mephitic cloud:mcdp
#spell_slot += Metabolic englaciation:mcn
#spell_slot += Monstrous menagerie:mst
#spell_slot += Necromutation:eou
#spell_slot += Olgreb's toxic radiance:oia
#spell_slot += Orb of destruction:dbn
#spell_slot += Ozocubu's armour:oau
#spell_slot += Ozocubu's refrigeration:cbz
#spell_slot += Pain:pnai
#spell_slot += Passage of golubria:uoi
#spell_slot += Passwall:aeu
#spell_slot += Petrify:pyt
#spell_slot += Poisonous vapours:pvs
#spell_slot += Portal projectile:oei
#spell_slot += Sandblast:zst
#spell_slot += Searing ray:sry
#spell_slot += Shadow creatures:scw
## Upper-case to prevent miskeys.
#spell_slot += Shatter:STH
#spell_slot += Shock:zok
#spell_slot += Simulacrum:scm
#spell_slot += Silence:SLC
#spell_slot += Slow:swlh
#spell_slot += Spellforged servitor:spvt
#spell_slot += Spider form:sprf
#spell_slot += Static discharge:tdc
#spell_slot += Statue form:stmf
#spell_slot += Sticky flame:yfk
#spell_slot += Sting:zptg
#spell_slot += Stone arrow:wtn
#spell_slot += Storm form:somf
#spell_slot += Summon forest:ftms
#spell_slot += Summon guardian golem:gds
#spell_slot += Summon horrible things:hts
#spell_slot += Summon hydra:hsy
#spell_slot += Summon ice beast:bct
#spell_slot += Summon lightning spire:lst
#spell_slot += Summon mana viper:vms
#spell_slot += Summon small mammal:zsm
#spell_slot += Swiftness:ieao
#spell_slot += Teleport other:tprh
#spell_slot += Tornado:TDN
#spell_slot += Tukima's Dance:dkc
#spell_slot += Vampiric draining:vnd
#spell_slot += Wereblood:wbld
#spell_slot += Yara's violent unraveling:yvgl

# Default letters
spell_slot += .*:hjklyubn

##################
### Item slots ###
##################

## Rings, in order of letter used.
item_slot += ring of dexterity : Dd
item_slot += ring of evasion : Ee
item_slot += ring of .*fire : Ff
item_slot += ring of (ice|protection from cold) : Cc
item_slot += ring of intelligence : Ii
item_slot += ring of flight : L
item_slot += ring of magical power : Mm
item_slot += ring of positive energy : Nn
item_slot += ring of poison resistance : P
item_slot += ring of resist corrosion : R
item_slot += ring of strength : Ss
item_slot += ring of see invisible : v
item_slot += ring of willpower: Ww
# Need numeric match to not trigger for rF/rC rings
item_slot += \+[0-9]+ ring of protection : Tt
item_slot += ring of slaying : Yy
item_slot += ring of wizardry : Zz

########################
### Autoinscriptions ###
########################

#  !*	Will prompt before any action with this item.
#  !a	Will prompt before attacking with this item.
#  !w	Will prompt before wielding or unwielding this item.
#  !e	Will prompt before eating.
#  !q	Will prompt before quaffing.
#  !r	Will prompt before reading.
#  !f	Will prompt before throwing or firing.
#  !W	Will prompt before wearing armour.
#  !T	Will prompt before taking off armour.
#  !P	Will prompt before putting on jewellry.
#  !R	Will prompt before removing jewellry.
#  !v	Will prompt before evoking an item.
#  !Q	Will prompt before quivering an item.
#  !p	Will prompt before sacrificing a anything in a stack containing this item.
# =p	Will prompt before sacrificing this item, but allows stack to be sacrificed.
# =g	Will automatically pick this item up if autopickup is on.
# =k	Will be ignored in listings on the ground.
# =s	If stash tracking is explicit, dropping this marks a stash to be tracked.
# =f	This item will be excluded with cycling ammunition and in automatic quivering.
# +f	This item is included in cycling ammunition and automatic quivering.
#  !D	Will prompt before performing any action that might destroy this item.

show_god_gift = unident

ai := autoinscribe

ai += .*potion:!q
#ai += .*scroll:!r

# Double Confirmationai += scrolls? of (summoning|silence|vulnerability|immolation|fog|butterflies|teleport|fear|torment):!r

ai += of faith:!P
ai += manual of:!d
# Prevent melee with all staves; if we want to melee with one, it's safe to
# require removing the annotation.
ai += magical staff:!a
ai += (large rock|throwing net|curare|of dispersal):=f

# Convenient shortcuts
ai += potions? of curing:@q1
ai += potions? of heal wounds:@q2
ai += potions? of haste:@q3
ai += potions? of cancellation:@q4
ai += scrolls? of identify:@r1
ai += scrolls? of blink:@r2
ai += scrolls? of teleportation:@r3

ai += datura:Berserk =f
ai += atropa:Blindness =f
ai += curare:Toxic =f

#ai += potion:!q
#ai += scroll:!r


##############
### Morgue ###
##############

note_hp_percent = 10
note_all_skill_levels = true
note_chat_messages = false
user_note_prefix = >>

note_items += experience,of resistance, Archmagi
note_items += crystal plate armour,pearl dragon scales
note_items += artefact
note_messages += You feel monstrous
note_messages += You pass through the gate
note_messages += cast .* Abyss

# Noteable monsters
# Undead
note_monsters += ancient lich, dread lich,curse skull,curse toe,royal mummy
# Depths
note_monsters += caustic shrike
# Special hall_of_zot spawns
note_monsters += killer klown,electric golem,orb of fire

dump_message_count = 1000
dump_order  = header,hiscore,stats,misc,mutations,skills,spells,inventory
dump_order += overview,screenshot,monlist,messages,skill_gains,action_counts
dump_order += vaults,notes,kills,turns_by_place,xp_by_level

dump_kill_places = all
dump_item_origins = all
dump_book_spells = false

###########
### Lua ###
###########


########runrest.rc########

# Aliases
stop := runrest_stop_message
ignore := runrest_ignore_message

# Ignore these stops
interrupt_travel -= sense_monster
interrupt_travel -= mimic

# Monsters to ignore at a distance
runrest_ignore_monster += fire vortex:1
runrest_ignore_monster += neutral:1

# Message mutes: CAREFUL WITH THESE!
message_colour += mute:plain:No target in view!

# Stop for consumables you want to use immediately
stop += potions? of experience
stop += scrolls? of acquirement

# Don't stop for noisy doors unless someone shouts back
stop -= it creaks loudly
stop -= flies open with a bang
stop += You hear

# Re-enable stops for all ally actions then ignore some
ignore -= friend_action:
ignore -= friend_spell:
ignore -= friend_enchant:
ignore ^= butterfly disappears
ignore ^= friend_action:(a|the) web
ignore ^= friend_action:(seems|blinks)
stop += friend_action:
stop += friend_spell:
stop += friend_enchant:
stop += appears from out of your range of vision
stop += hits your
stop += our.*is destroyed

# Expiring effects; Turn on transmutation|flight|swiftness ending and ignore the rest
ignore -= transformation is almost over\.
ignore -= transformation has ended\.
ignore -= revert to a slightly less stony form\.
ignore -= revert to your normal fleshy form\.
ignore -= You feel yourself come back to life
ignore ^= unholy channel is weakening
ignore ^= magical contamination.*faded
ignore ^= our foxfire dissipates
stop ^= transformation is almost over
stop ^= transformation has ended
stop ^= revert to a slightly less stony form\.
stop ^= revert to your normal fleshy form
stop ^= feel yourself come back to life
stop ^= unholy channel expires
stop ^= are starting to lose your buoyancy
stop ^= feel.*sluggish
# Expiring effects for friends too
stop ^= no longer petrified
ignore ^= no longer covered in acid

# Misc
stop -= You now have enough gold to

ignore ^= nearby plant withers and dies
ignore ^= disentangle yourself
ignore ^= You swap places.

# Summonings
ignore ^= our.*crimson imp blinks
ignore ^= our.*simulacrum vaporises
ignore ^= our.*returns to the shadows of the Dungeon
ignore ^= our.*skeleton crumbles into dust
ignore ^= our.*fades into mist

########fm-messages.rc########

# Alias
more := force_more_message

# Remove annoying defaults
more -= You have reached level
more -= The lock glows eerily
more -= Heavy smoke blows from the lock
more -= The gate opens wide
more -= With a soft hiss the gate opens wide
more -= You pick up the .* rune and feel its power


# Significant spells/effects ending
more += is no longer charmed
more += You are starting to lose your buoyancy
# Death's Door
more += time is.*running out
more += life is in your own
# Death channel
more += unholy channel is weakening


# Monsters doing things
more += monster_warning:wielding.*of chaos
more += monster_warning:carrying a wand of
more += monster_warning:curare
more += (?<!You)(?<!yourself) speeds? up
more += danger:goes berserk
more += The forest starts to sway and rumble
more += begins to recite a word of recall
more += doors? slams? shut
more += blows on a signal horn
more += The.*offers itself to Yredelemnul
more += Deactivating autopickup
more += Your?.*suddenly stops? moving
more += There is.*feeling in your soul
more += swoops through the air toward you
more += Its appearance distorts for a moment
more += wretched star pulses
more += Strange energies course through your body


# Crowd control
more += You ((?<!( too|less)) confused|blown|knocked back|mesmerised|trampled|stumble backwards|encased|(?<!hands )slow.*down|lose consciousness)
more += infuriates you
more += danger:Space.*around you
more += hits you.*distortion
more += The pull of.*song draws you forward
more += The.*engulfs you in water
more += surroundings become eerily quiet
more += Your limbs are stiffening
more += Your magical effects are unraveling
more += Your magical defenses are stripped away
more += You stop (a|de)scending the stairs
more += A sentinel's mark forms upon you


# Clouds
more += danger:(calcify|mutagenic)
more += You are engulfed in.*miasma
more += Miasma billows from the


# You Screwed Up
more += power of Zot
more += is no longer ready
more += You really shouldn't be using
more += You don't have enough magic to cast this spell
more += Your body shudders with the violent release


# Found something important
more += Found a staircase to the Ecumenical Temple
more += timed_portal:.*
more += Found.*(treasure|bazaar|ziggurat)
more += .*resides here
more += You have a vision of.*gates?


# Translocations
more += You blink
more += danger:You feel strangely .*stable
more += danger:sense of stasis
more += Your surroundings.*(different|flicker)
more += You are suddenly pulled into a different region
more += delayed


# Big damage
more += your body is wracked
more += Ouch! That really hurt!
more += silver sears you
more += The poison in your body grows stronger
more += You.*re (more poisoned|lethally poisoned)
more += danger:You convulse
more += You feel a (horrible|terrible) chill
more += You are (blasted|electrocuted|burned terribly)


# Hit by something
more += Terrible wounds
more += danger:corrodes you
more += The air around.*erupts in flames
more += The air twists around and violently strikes you in flight
more += You shudder from the earth-shattering force
more += You feel.*(?<!less )(haunted|rot|vulnerable)
more += Your damage is reflected back at you
more += (?<!You.*)reflects


# FYI
more += seems mollified
more += You have finished your manual


# Unexpected monsters
more += appears in a (shower|flash)
more += appears out of thin air
more += You sense the presence of something unfriendly
more += Wisps of shadow swirl around


# Misc
more += hell effect:.*
more += god:wrath finds you
more += The walls disappear
more += guardian golem overheats


## If you understand this, I trust you not to troll me
more += dgl_message:.*


###########
### Lua ###
###########

{
-- Equipment autopickup (by Medar and various others)
local function pickup_equipment(it, name)
  if it.is_useless then return end

  local class = it.class(true)
  if class == "armour" then
    local good_slots = {cloak="Cloak", helmet="Helmet",
                        gloves="Gloves", boots="Boots"}
    st, _ = it.subtype()

    -- Autopickup found aux armour if 1) we don't have any or 2) it's artefact,
    -- or 3) if we don't have artefact or ego armour, and the found armour is
    -- ego.
    if good_slots[st] ~= nil then
      if good_slots[st] == "Gloves" and you.has_claws() > 0 then return end

      if it.artefact then return true end

      local cur = items.equipped_at(good_slots[st])
      if cur == nil then return true end

      if cur.branded or cur.artefact then return end
      if it.branded then return true end
      -- Autopickup found body armour of the same kind we're wearing, according
      -- to conditions (2) and (3) above used for aux slots.
    elseif st == "body" then
      local cur = items.equipped_at("armour")
      if cur == nil then return end
      if cur.name("qual") ~= it.name("qual") then return end

      if it.artefact then return true end

      if cur.branded or cur.artefact then return end
      if it.branded then return true end
    end
  end
  return
end

add_autopickup_func(pickup_equipment)

-- Spellcasting spam reduction by monqy
local function generic_cast_spell(cmd)
  crawl.mpr('<cyan>Cast which spell?</cyan>')
  crawl.flush_prev_message()
  crawl.process_keys(cmd)
end

function cast_spell()
  generic_cast_spell('z')
end

function force_cast_spell()
  generic_cast_spell('Z')
end
}



########fm-monsters.rc########

{
------------------------------------------------------------------------------------------
------------------------------- Monster force_mores config -------------------------------
------------------------------------------------------------------------------------------
-- This stops on all Uniques & Pan lords
crawl.setopt("force_more_message += monster_warning:(?!Orb)(?!Guardian)(?-i:[A-Z]).*comes into view")

---- Everything included in this list will cause a more() prompt.
---- It should contain monsters that always need alerts, regardless of HP, xl, willpower, and resistances
local force_more_monsters = {
  -- High damage/speed
    "shrike", "juggernaut", "orbs? of fire", "flayed ghost",
  -- Torment
    "tormentor", "curse (toe|skull)", "Fiend", "tzitzimi", "royal mummy", "mummy priest", "(dread|ancient) lich", "lurking horror",
  --Summoning
    "boggart", "shadow demon", "guardian serpent", "ironbound convoker", "draconian stormcaller", "spriggan druid", "dryad",
    "worldbinder", "halazid warlock", "deep elf elementalist", "demonspawn corrupter", "elemental wellspring",
  --Dangerous abilities
    "swamp worm", "floating eye", "vault warden", "air elemental", "wendingo", "torpor snail", "dream sheep", "water nymph", 
    "shambling mangrove", "iron giant", "starflower", "merfolk aquamancer", "deep elf knight", "wretched star",
  --Dangerous clouds
    "catoblepas", "death drake", "apocalypse crab", "putrid mouth" }


------------------------------------------------------------------------------------------
------------------------------- Dynamic force_mores config -------------------------------
------------------------------------------------------------------------------------------
-- hp-specific force_mores() by gammafunk, willpower/int/resistance added by sockthot
local fm_patterns = {
  -- Fast, early game Dungeon problems for chars with low mhp.
  {name = "30hp", cond = "hp", cutoff = 30, pattern = "hound"},
  
  -- Monsters dangerous until a certain point
  {name = "xl_7", cond = "xl", cutoff = 7, pattern = "orc wizard"},
  {name = "xl_12", cond = "xl", cutoff = 12, pattern = "hydra|bloated husk"},
  
  
  -- Monsters that can hit for ~50% of hp from range with unbranded attacks
  {name = "40hp", cond = "hp", cutoff = 40, pattern = "orc priest" },
  {name = "50hp", cond = "hp", cutoff = 50, pattern = "orc high priest|manticore" },
  {name = "70hp", cond = "hp", cutoff = 70, pattern = "meliai|yaktaur(?! captain)|cyclops" },
  {name = "80hp", cond = "hp", cutoff = 80, pattern = "centaur(?! warrior)|gargoyle" },
  {name = "90hp", cond = "hp", cutoff = 90, pattern = "deep elf archer|tengu conjurer" },
  {name = "110hp", cond = "hp", cutoff = 110, pattern = {"centaur warrior|yaktaur captain|hellion|eye of devastation|sun moth",
              "deep elf high priest|deep troll earth mage|stone giant|cacodemon"} },
  {name = "120hp", cond = "hp", cutoff = 120, pattern = "quicksilver (dragon|elemental)|magenta draconian|thorn hunter" },
  {name = "160hp", cond = "hp", cutoff = 160, pattern = {"brimstone fiend|deep elf sorcerer",
              "hell sentinal|war gargoyle|draconian (knight|scorcher)"} },
  {name = "200hp", cond = "hp", cutoff = 200, pattern = "(draconian|deep elf) annihilator|iron (dragon|elemental)" },

  -- Monsters that can crowd-control you without sufficient willpower
  -- Cutoff ~10% for most spells; lower for more significant spells like banish
  {name = "willpower2", cond = "will", cutoff = 2, pattern = "basilisk|naga ritualist|vampire(?! bat)(?! mage)(?! mosquito)" },
  {name = "willpower3", cond = "will", cutoff = 3, pattern = {"deep elf (demonologist|sorcerer|archer)|(?<!orc )wizard", 
              "merfolk siren|fenstrider witch|great orb of eyes|cacodemon|imperial myrmidon|sphinx|nagaraja|draconian shifter",
              "orange crystal statue|glowing orange brain|orc sorcerer|ogre mage|satyr|vault sentinel",
              "iron elemental|golden eye|death knight|vampire knight" } },
  {name = "willpower4", cond = "will", cutoff = 4, pattern = "merfolk avatar|tainted leviathan|nargun" },
   
  -- Malmutate without rMut
  {name = "malmutate", cond = "mut", cutoff = 1, pattern = "cacodemon|neqoxec|shining eye" },
    
  -- Brain feed with low int
  {name = "brainfeed", cond = "int", cutoff = 6, pattern = "glowing orange brain|neqoxec|orange crystal statue" },
    
  -- Alert if no resist and HP below cutoff
  {name = "pois_30", cond = "pois", cutoff = 30, pattern = "adder"},
  {name = "pois_80", cond = "pois", cutoff = 80, pattern = "golden dragon|green draconian|swamp dragon" },
  {name = "pois_120", cond = "pois", cutoff = 120, pattern = "green death|naga mage|nagaraja|fenstrider witch" },
  {name = "pois_140", cond = "pois", cutoff = 140, pattern = "tengu reaver" },
   
  {name = "elec_40", cond = "elec", cutoff = 40, pattern = "electric eel" },
  {name = "elec_80", cond = "elec", cutoff = 80, pattern = "shock serpent|raiju|spark wasp" },
  {name = "elec_120", cond = "elec", cutoff = 120, pattern = "black draconian|blizzard demon|deep elf zephyrmancer|storm dragon|tengu conjurer" },
  {name = "elec_140", cond = "elec", cutoff = 140, pattern = "electric golem|titan|servants? of whisper|spriggan air mage|ball lightning|tengu reaver" },
   
  {name = "corr_60", cond = "corr", cutoff = 60, pattern = "acid dragon" },
  {name = "corr_140", cond = "corr", cutoff = 140, pattern = "tengu reaver|entropy weaver|demonspawn corrupter|moon troll" },
   
  {name = "fire_60", cond = "fire", cutoff = 60, pattern = "steam dragon|lindwurm|fire crab|lava snake" },
  {name = "fire_100", cond = "fire", cutoff = 100, pattern = "efreet|deep elf pyromancer|smoke demon|sun moth" },
  {name = "fire_120", cond = "fire", cutoff = 120, pattern = "orc sorcerer|hell hound|demonspawn blood saint|red draconian|ogre mage|molten gargoyle|hell knight" },
  {name = "fire_140", cond = "fire", cutoff = 140, pattern = "balrug" },
  {name = "fire_160", cond = "fire", cutoff = 160, pattern = "will-o-the-wisp|ophan|fire giant|golden dragon|fire dragon|salamander tyrant|tengu reaver" },
  {name = "fire_240", cond = "fire", cutoff = 240, pattern = "hellephant|crystal (guardian|echidna)|draconian scorcher" },
   
  {name = "cold_80", cond = "cold", cutoff = 80, pattern = "rime drake" },
  {name = "cold_120", cond = "cold", cutoff = 120, pattern = "blizzard demon|bog body|ironbound frostheart|demonspawn blood saint|white draconian" },
  {name = "cold_160", cond = "cold", cutoff = 160, pattern = "golden dragon|draconian knight|frost giant|ice dragon|tengu reaver" },
  {name = "cold_180", cond = "cold", cutoff = 180, pattern = "(?>!dread)(?>!ancient) lich" },
  {name = "cold_240", cond = "cold", cutoff = 240, pattern = "crystal (guardian|echidna)" },
   
  {name = "drain_100", cond = "drain", cutoff = 100, pattern = "orc sorcerer" },
  {name = "drain_120", cond = "drain", cutoff = 120, pattern = "necromancer" },
  {name = "drain_150", cond = "drain", cutoff = 150, pattern = "revenant|demonspawn blood saint" },
  {name = "drain_190", cond = "drain", cutoff = 190, pattern = "shadow dragon" },
   
} -- end fm_patterns

----------------------------------------------------------------------------------
------------------------------- End config section -------------------------------
----------------------------------------------------------------------------------



-- Add the non-dynamic force_mores()  (moved code down here for easier configuration)
local fm_mon_str = nil
for _, v in ipairs(force_more_monsters) do
  if fm_mon_str == nil then
    fm_mon_str = "monster_warning:(?<!spectral )("..v
  else
    fm_mon_str = fm_mon_str.."|"..v
  end
end
fm_mon_str = fm_mon_str..")(?! (zombie|skeleton|simulacrum).*comes into view"
crawl.setopt("force_more_message += "..fm_mon_str)




-- Set to true to get a message when the fm change
local notify_fm = false

-- Keep track of active force_mores()
local active_fm = {}
for i,v in ipairs(fm_patterns) do
  active_fm[#active_fm + 1] = false
end

-- Util for checks against resistance and hp
local function get_three_pip_action(active, hp, cutoff, res)
  if active then
    if hp >= cutoff then return "-" end
    if res == 1 and hp >= cutoff/2 then return "-" end
    if res == 2 and hp >= cutoff/3 then return "-" end
    if res == 3 and hp >= cutoff/5 then return "-" end
  else
    if res == 0 and hp < cutoff then return "+" end
    if res == 1 and hp > cutoff/2 then return "+" end
    if res == 2 and hp > cutoff/3 then return "+" end
    if res == 3 and hp > cutoff/5 then return "+" end
  end
end



--------------------------------------------
------------------- Hook -------------------
--------------------------------------------
function ready_force_mores()
  local activated = {}
  local deactivated = {}
  
  local hp, maxhp = you.hp()
  local willpower = you.willpower()
  local res_mut = you.res_mutation()
  local res_pois = you.res_poison()
  local res_elec = you.res_shock()
  local res_corr = you.res_corr()
  local res_fire = you.res_fire()
  local res_cold = you.res_cold()
  local res_drain = you.res_draining()
  local int, maxint = you.intelligence()
  
  for i,v in ipairs(fm_patterns) do
    local msg = nil
    if type(v.pattern) == "table" then
      for j, p in ipairs(v.pattern) do
        if not msg then
          msg = p
        else
          msg = msg .. "|" .. p
        end
      end
    else
      msg = v.pattern
    end
    
    msg = "monster_warning:(?<!spectral )(" .. msg .. ")(?! (skeleton|zombie|simulacrum)).*comes into view"
    
    local action = nil
    local fm_name = v.pattern
    if v.name then fm_name = v.name end
    
    if not v.cond and not active_fm[i] then
      action = "+"
    elseif v.cond == "xl" then
      if active_fm[i] and you.xl() >= v.cutoff then action = "-"
      elseif not active_fm[i] and you.xl() < v.cutoff then action = "+"
      end
    elseif v.cond == "maxhp" then
      if active_fm[i] and maxhp >= v.cutoff then action = "-"
      elseif not active_fm[i] and maxhp < v.cutoff then action = "+"
      end
    elseif v.cond == "hp" then
      if active_fm[i] and hp >= v.cutoff then action = "-"
      elseif not active_fm[i] and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "int" then
      if active_fm[i] and int >= v.cutoff then action = "-"
      elseif not active_fm[i] and int < v.cutoff then action = "+"
      end
    elseif v.cond == "will" then
      if active_fm[i] and willpower >= v.cutoff then action = "-"
      elseif not active_fm[i] and willpower < v.cutoff then action = "+"
      end
    elseif v.cond == "mut" then
      if active_fm[i] and res_mut > 0 then action = "-"
      elseif not active_fm[i] and res_mut == 0 then action = "+"
      end
    elseif v.cond == "pois" then
      if active_fm[i] and (res_pois > 0 or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and res_pois == 0 and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "elec" then
      if active_fm[i] and (res_elec > 0 or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and res_elec == 0 and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "corr" then
      if active_fm[i] and (res_corr or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and not res_corr and hp < v.cutoff then action = "+"
      end
    elseif v.cond == "fire" then
      action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_fire)
    elseif v.cond == "cold" then
      action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_cold)
    elseif v.cond == "drain" then
      action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_drain)
    end
    
    
    if action == "+" then
      activated[#activated + 1] = fm_name
    elseif action == "-" then
      deactivated[#deactivated + 1] = fm_name
    end
    if action then
      local opt = "force_more_message " .. action .. "= " .. msg
      crawl.setopt(opt)
      active_fm[i] = not active_fm[i]
    end
  end
  if #activated > 0 and notify_fm then
    crawl.mpr("Activating force_mores: " .. table.concat(activated, ", "), "plain")
  end
  if #deactivated > 0 and notify_fm then
    crawl.mpr("Deactivating force_mores: " .. table.concat(deactivated, ", "), "plain")
  end
end
}

########dynamic-options.rc########

{
----------------------
---- race-specific ----
----------------------
if you.race() == "Demonspawn" then
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
elseif you.race() == "Formicid" then
  crawl.setopt("more -= monster_warning:curare")
elseif you.race() == "Gargoyle" then
  crawl.setopt("more -= monster_warning:curare")
elseif you.race() == "Ghoul" then
  crawl.setopt("more -= monster_warning:curare")
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
elseif you.race() == "Gnoll" then
  crawl.setopt("message_colour ^= mute:intrinsic_gain:skill increases to level")
elseif you.race() == "Mummy" then
  crawl.setopt("more -= monster_warning:curare")
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
end


----------------------
---- god-specific ----
----------------------
local cur_god = "No God"
local function set_god_options()
  if you.god() ~= cur_god then
    cur_god = you.god()
  
    if cur_god == "Beogh" then
      crawl.setopt("autopickup_exceptions ^= >scrolls? of immolation")
      crawl.setopt("runrest_ignore_message += no longer looks unusually strong")
      crawl.setopt("force_more_message += Your orc.*dies")
      --crawl.setopt("macros += M 1 tf")
      --crawl.setopt("macros += M 2 ta")
      --crawl.setopt("macros += M 3 tr")
      --crawl.setopt("macros += M 4 tg")
      --crawl.setopt("macros += M 6 ab")
    elseif cur_god == "Dithmenos" then
      crawl.setopt("force_more_message += god:You are shrouded in an aura of darkness")
      crawl.setopt("force_more_message += god:You now sometimes bleed smoke")
      crawl.setopt("force_more_message += god:You.*no longer.*bleed smoke")
      crawl.setopt("force_more_message += god:Your shadow no longer tangibly mimics your actions")
      crawl.setopt("force_more_message += god:Your shadow now sometimes tangibly mimics your actions")
    elseif cur_god == "Fedhas" then
      crawl.setopt("force_more_message += god:Fedhas invokes the elements against you")
    elseif cur_god == "Hepliaklqana" then
      crawl.setopt("runrest_ignore_message ^= emerges from the mists of memory")
    elseif cur_god == "Jiyva" then
      crawl.setopt("force_more_message += god:will now unseal the treasures of the Slime Pits")
      crawl.setopt("force_more_message += god:Jiyva alters your body")
      crawl.setopt("force_more_message += god:splits in two")
      crawl.setopt("force_more_message += god:Your prayer is over.")
    elseif cur_god == "Kikubaaqudgha" then
      crawl.setopt("force_more_message += god:Kikubaaqudgha will grant you")
    elseif cur_god == "Lugonu" then
      crawl.setopt("force_more_message += god:Lugonu will now corrupt your weapon")
      crawl.setopt("force_more_message += god:Lugonu sends minions to punish you")
    elseif cur_god == "Okawaru" then
      crawl.setopt("force_more_message += god:Okawaru sends forces against you")
    elseif cur_god == "Qazlal" then
      crawl.setopt("force_more_message += god:resistances upon receiving elemental damage")
      crawl.setopt("force_more_message += god:You are surrounded by a storm which can block enemy attacks")
    elseif cur_god == "The Shining One" then
      crawl.setopt("force_more_message += god:Your divine shield starts to fade.")
      crawl.setopt("force_more_message += god:Your divine shield fades away.")
    elseif cur_god == "Trog" then
      crawl.setopt("force_more_message += god:You feel the effects of Trog's Hand fading")
      crawl.setopt("force_more_message += god:You feel less resistant to hostile enchantments")
    elseif cur_god == "Uskayaw" then
      crawl.setopt("force_more_message += god:You can no longer pass through a line of other dancers.")
    elseif cur_god == "Wu Jian Council" then
      crawl.setopt("runrest_ignore_message += heavenly storm settles")
    elseif cur_god == "Xom" then
      crawl.setopt("force_more_message += god:")
      crawl.setopt("force_more_message += staircase.*moves")
      crawl.setopt("force_more_message += Some monsters swap places")
    elseif cur_god == "Yredelemnul" then
      crawl.setopt("force_more_message += god:soul is now ripe for the taking")
      crawl.setopt("force_more_message += god:soul is no longer ripe for the taking")
      crawl.setopt("force_more_message += god:dark mirror aura disappears")
    elseif cur_god == "Zin" then
      crawl.setopt("force_more_message += god:will now cure all your mutations")
    end
  end
end



---------------------
---- xl-specific ----
---------------------
local warn_early_levels = false
local warn_mid_levels = false
local function set_xl_options()
  if not warn_early_levels and you.xl() <= 5 then
    warn_early_levels = true
    crawl.setopt("force_more_message += wielding.*(vorpal|(?<!armour)(?<!mail)(?<!scales) of)")
  elseif warn_early_levels and you.xl() > 5 then
    warn_early_levels = false
    crawl.setopt("force_more_message -= wielding.*(vorpal|(?<!armour)(?<!mail)(?<!scales) of)")
  end
  
  if not warn_mid_levels and you.xl() <= 10 then
    warn_mid_levels = true
    crawl.setopt("force_more_message += wielding.*of electrocution")
  elseif warn_mid_levels and you.xl() > 10 then
    warn_mid_levels = false
    crawl.setopt("force_more_message -= wielding.*of electrocution")
  end
end


------------------------
---- skill-specific ----
------------------------
local ignoring_spellcasting = false
local function set_skill_options()
  -- Ignore spellcaster items if you have no spellcasting skill, and wearing some armour without much armour skill
  local arm = items.equipped_at("body armour")
  if not ignoring_spellcasting and you.skill("Spellcasting") == 0 and arm and arm.encumbrance > you.skill("Armour") then
    ignoring_spellcasting = true
    crawl.setopt("explore_stop_pickup_ignore += spellbooks")
    crawl.setopt("autopickup_exceptions ^= >scrolls? of amnesia, >potions? of brilliance, >ring of wizardry")
    crawl.setopt("runrest_ignore_message += You add the spell")
  elseif ignoring_spellcasting and not (you.skill("Spellcasting") == 0 and arm and arm.encumbrance > you.skill("Armour")) then
    ignoring_spellcasting = false
    crawl.setopt("explore_stop_pickup_ignore -= spellbooks")
    crawl.setopt("autopickup_exceptions -= >scrolls? of amnesia, >potions? of brilliance, >ring of wizardry")
    crawl.setopt("runrest_ignore_message -= You add the spell")
  end
end



------------------------------------------
------------------ Hook ------------------
------------------------------------------
function ready_dynamic_options()
  --set_god_options()
  --set_xl_options()
  --set_skill_options()
end

}

########startup.rc########

{
-------------------------------------------------
---- Start with travel speed to slowest ally ----
-------------------------------------------------
-- Make sure this comes before Skill menu on startup, since they both use crawl.sendkeys()
local need_toggle_travel_speed = true
if you.turns() == 0 and need_toggle_travel_speed then
  need_toggle_travel_speed = false
  crawl.sendkeys(20)
end


---------------------------------------------
---- Skill menu on startup (by rwbarton) ----
---------------------------------------------
local need_skills_opened = true
if you.turns() == 0 and need_skills_opened then
  need_skills_opened = false
  crawl.sendkeys("m!!")
end

}


########features/remind-id.rc########

{
-------------------------------------
---- Unidentified items reminder ----
-------------------------------------
local function remind_unidentified_items(have_unidentified)
  for it in iter.invent_iterator:new(items.inventory()) do
    if not it.fully_identified then
      for s in iter.invent_iterator:new(items.inventory()) do
        if s and s.name("qual"):find("scroll of identify") then
          crawl.mpr("<magenta>----You have something to identify.----</magenta>", "plain")
        end
      end
      
      return
    end
  end
end
crawl.setopt("runrest_stop_message += You have something to identify")



---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_message_remind_identify(text, channel)
  if channel ~= "plain" then return end

  if text:find(" of identify") and not text:find("drop") and not text:find("read") then
    remind_unidentified_items(false)
  end
end

function c_assign_invletter_remind_identify(it)
  if not it.fully_identified then remind_unidentified_items(true) end
end
}

########features/weapon-slots.rc########

{
------------------------------
---- Cleanup weapon slots ----
------------------------------
--Whenever you drop an item:
    -- Assign weapons to slots a and b
        -- Priority: 1:wielded, 2:weapon, not polearm/ranged unless skill
        -- 3:magical staff, 4:polearm
    -- Assign weap to w: ranged/polearm/any


local function get_first_empty_slot()
  for slot=1,52 do
    if not items.inslot(slot) then return slot end
  end
end

local function get_priority_ab(it)
  if not it or not it.weap_skill then return -1 end
  if it.equipped then return 1 end
  
  local class = it.class(true)
  if class == "magical staff" then return 3 end
  if class == "weapon" then
    if it.is_ranged then    
      if you.skill("Ranged Weapons") >= 4 then return 2 end
      return 5
    end
    
    if it.weap_skill == "Polearms" then
      if you.skill("Polearms") >= 4 then return 2 end
      return 4
    end
    
    return 2
  end
  
  return -1
end

local function get_priority_w(it)
  if not it or not it.weap_skill then return -1 end
  if it.is_ranged then return 1 end
  if it.weap_skill == "Polearms" then return 2 end
  return 3
end



--------------
---- main ----
--------------
local priorities_ab = nil
local priorities_w = nil
local function generate_priorities()
  priorities_ab = { -1, -1, -1, -1, -1 }
  priorities_w = { -1, -1, -1 }
  
  for it in iter.invent_iterator:new(items.inventory()) do
    local p = get_priority_w(it)
    if p > 0 then
      if priorities_w[p] == -1 then priorities_w[p] = it.slot
      else priorities_w[p+1] = it.slot
      end
    end
    
    p = get_priority_ab(it)
    if p > 0 then
      if priorities_ab[p] == -1 then priorities_ab[p] = it.slot
      else priorities_ab[p+1] = it.slot
      end
    end
  end
end


local function cleanup_w()
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if inv and inv.class(true) == "weapon" then return end

  for p=1,3 do
    if priorities_w[p] > 1 then
      items.swap_slots(priorities_w[p], slot_w)
      return
    end
  end
end

local function cleanup_ab(ab)
  local inv
  inv = items.inslot(ab)
  if inv and inv.class(true) == "weapon" then return end

  for p=1,5 do
    if priorities_ab[p] > ab then
      items.swap_slots(priorities_ab[p], ab)
      priorities_ab[p] = -1
      return
    end
  end
end

local function cleanup_weapon_slots()
  generate_priorities()
  cleanup_ab(0)
  cleanup_ab(1)
  cleanup_w()
end





local do_cleanup_weapon_slots = false

---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_assign_invletter_weapon_slots(it)
  if it.class(true) ~= "weapon" and it.class(true) ~= "magical staff" then return end
  
  for i=0,2 do
    local slot
    if i==2 then slot = items.letter_to_index("w")
    else slot = i
    end
    
    local inv = items.inslot(slot)
    if not inv then return slot end
    if inv.class(true) ~= "weapon" and inv.class(true) ~= "magical staff" then
      items.swap_slots(slot, get_first_empty_slot())
      return slot
    end
  end
end



function c_message_weapon_slots(text, channel)
  if channel ~= "plain" then return end
  if not text:find("You drop ") then return end
  do_cleanup_weapon_slots = true
end



function ready_weapon_slots()
  if do_cleanup_weapon_slots then
    cleanup_weapon_slots()
    do_cleanup_weapon_slots = false
  end
end

}

########features/exclude-dropped.rc########

{
-- Add autopickup exclusion for any jewellery/missile/evocable item that is dropped
-- Exclusion is removed when you pick the item back up

-------------------------
---- Persistant data ----
-------------------------
if not dropped_item_exclusions or you.turns() == 0 then
  dropped_item_exclusions = ""
end

local function persist_dropped_item_exclusions()
  return "dropped_item_exclusions = \""..dropped_item_exclusions.."\""..string.char(10)
end

if not added_exclude_dropped_hooks then
  table.insert(chk_lua_save, persist_dropped_item_exclusions)
  added_exclude_dropped_hooks = true
end


local function get_jewellery_name(text)
  local idx  = text:find("ring of ")
  if not idx then idx = text:find("amulet of ") end
  if not idx then return end
  
  text = text:gsub(" {.*}", "")
  text = text:gsub("[.]", "")
  return text:sub(idx,#text)
end

local all_missiles = { " stone", "poisoned dart", "curare", "atropa", "datura", "boomerang", "javelin" }
local function get_missile_name(text)
  for _, item_name in ipairs(all_missiles) do
    if text:find(item_name) then
      if item_name == "boomerang" or item_name == "javelin" then
        if text:find("silver") then
          item_name = "silver "..item_name
        elseif text:find("dispersal") then
          item_name = item_name.."s? of dispersal"
        else
          item_name = "(?<!silver )"..item_name.."(?!(s? of dispersal))"
        end
      end
      
      return item_name
    end
  end
end

local all_misc = { "phial of floods", "lightning rod", "tin of tremorstones", 
      "condenser vane", "box of beasts", "phantom mirror", "piece from Xom's chessboard" }
local function get_misc_name(text)
  for _, item_name in ipairs(all_misc) do
    if text:find(item_name) then return item_name end
  end
end



------------------------------------------
------------------ Hook ------------------
------------------------------------------

function c_message_exclude_dropped(text, channel)
  if channel ~= "plain" then return end
  
  local exclude
  if text:find("You drop ") then exclude = true
  elseif text:find(" %- ") then exclude = false
  else return
  end

  local item_name = get_jewellery_name(text)
  if not item_name then item_name = get_missile_name(text) end
  if not item_name then item_name = get_misc_name(text) end
  if not item_name then return end

  if exclude then
    crawl.setopt("autopickup_exceptions ^= >"..item_name)
    if dropped_item_exclusions ~= "" then dropped_item_exclusions = dropped_item_exclusions.."," end
  else
    crawl.setopt("autopickup_exceptions -= >"..item_name)
    -- Remove persistant exclusion (try 3 times to make sure we capture comma)
    dropped_item_exclusions = dropped_item_exclusions:gsub(",>"..item_name, "")
    dropped_item_exclusions = dropped_item_exclusions:gsub(">"..item_name..",", "")
    dropped_item_exclusions = dropped_item_exclusions:gsub(">"..item_name, "")
  end
end
if dropped_item_exclusions ~= "" then crawl.setopt("autopickup_exceptions ^= "..dropped_item_exclusions) end

}

########features/safe-consumables.rc########

###############################
####### Auto-inscribe #########
# Unidentified consumables
#autoinscribe += potions?(?!.*of ):!q
#autoinscribe += scrolls?(?!.*of ):!r

# Add a warning for everything that doesn't have one built-in
autoinscribe += potions? of(?!.*(attraction|lignification|mutation)):!q
autoinscribe += scrolls? of(butterflies|fear|fog|magic mapping|posion|silence|summoning|teleportation|torment|vulnerability):!r


{
--------------------------------------------
---- Protective consumable inscriptions ----
--------------------------------------------
-- Initialize to true to fix inscriptions on init (starting items don't get default inscriptions)
local no_inscriptions = {"acquirement", "amnesia", "blinking", "brand weapon", "enchant armour", "enchant weapon", 
                         "identify", "immolation", "noise", "poison", "vulnerability", "attraction", "lignification", "mutation" }

local function fix_inscriptions()
  -- Remove the default "!r" and "!q" inscriptions after identify
  local keystring = ""
  for it in iter.invent_iterator:new(items.inventory()) do    
    if it.fully_identified then
      local it_class = it.class(true)
      if it_class == "potion" or it_class == "scroll" then
        local qualname = it.name("qual")
        local st, _ = it.subtype()
        
        if util.contains(no_inscriptions, st) then
          if it.inscription:find("%!r") then it.inscribe(it.inscription:gsub("%!r", ""), false) end
          if it.inscription:find("%!q") then it.inscribe(it.inscription:gsub("%!q", ""), false) end
        elseif it_class == "scroll" and not util.contains(no_inscriptions, st) and not qualname:find("!r") then
          it.inscribe("!r")
        elseif it_class == "potion" and not util.contains(no_inscriptions, st) and not qualname:find("!q") then
          it.inscribe("!q")
        end
      end
    end
  end
end


local do_fix_inscriptions = true

---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function ready_safe_consumables()
  if do_fix_inscriptions then
    fix_inscriptions()
    do_fix_inscriptions = false
  end
end


function c_message_safe_consumables(text, channel)
  if channel ~= "plain" then return end
  local triggers = { "Thank you for shopping at", "s a scroll of ", "s a potion of ", "read the scroll of identify" }
  for _, v in ipairs(triggers) do
    if text:find(v) then
      fix_inscriptions()
      do_fix_inscriptions = true
      return
    end
  end
end

}

########features/runrest-features.rc########

{
--------------------------------
---- Fully rest off effects ----
--------------------------------
crawl.setopt("runrest_ignore_message += recovery:.*")
crawl.setopt("runrest_ignore_message += duration:.*")


local function fully_recovered()
  local status_wait = { "contam", "berserking", "on berserk cooldown", "short of breath", "corroded", "vulnerable"}
  for _, s in ipairs(status_wait) do
    if you.status(s) then return false end
  end
  return true
end

local waiting_for_recovery = false
local explore_after_recovery = false

-- Attach full recovery to auto-explore
function explore_full_recovery()
  if not fully_recovered() then
    explore_after_recovery = true
    crawl.do_commands({"CMD_REST"})
  elseif you.status("slowed") then
    if not (you.strength() <=0 or you.intelligence() <= 0 or you.dexterity() <=0) then
       explore_after_recovery = true
       crawl.do_commands({"CMD_REST"})
    else
      crawl.do_commands({"CMD_EXPLORE"})
    end
  else
    crawl.do_commands({"CMD_EXPLORE"})
  end
end
crawl.setopt("macros += M o ===explore_full_recovery")

-------------------------------------
---- Hooks (All functions below) ----
-------------------------------------

--------------------------------
---- rest off effects cont. ----
--------------------------------
function ch_stop_running_full_recovery(kind)
  if kind == "run" and not fully_recovered() then
    waiting_for_recovery = true
    crawl.setopt("message_colour += mute:You start waiting.")
  end
end

function c_message_fully_recover(text, channel)
--if text:find("contamination") then crawl.mpr(text) crawl.mpr(channel) end
  if text:find("You start waiting.") then
    if not fully_recovered() then
      waiting_for_recovery = true
      crawl.setopt("message_colour += mute:You start waiting.")
    end
  elseif waiting_for_recovery then
    you.stop_activity()
  end
end

function ready_fully_recover()
  if waiting_for_recovery then
    if fully_recovered() then
      you.stop_activity()
      crawl.setopt("message_colour -= mute:You start waiting.")
      waiting_for_recovery = false
      crawl.mpr("Fully recovered.")
      
      if explore_after_recovery then
        crawl.sendkeys("o")
        explore_after_recovery = false
      end
    else
      crawl.do_commands({"CMD_WAIT"})
    end
  end
end

--------------------------------------------------------------------
---- End Fully rest off effects (Hooks for other features cont. ----
--------------------------------------------------------------------

----------------------
---- Ignore altars ----
-----------------------
local stop_on_altars = true

function ready_ignore_altars()
  if stop_on_altars and (you.god() ~= "No God" or you.branch() == "Temple") then
    stop_on_altars = false
    crawl.setopt("explore_stop -= altars")
  elseif not stop_on_altars and you.god() == "No God" and you.branch() ~= "Temple" then
    stop_on_altars = true
    crawl.setopt("explore_stop += altars")
  end
end


-----------------------------------------------
---- Search altars in temple after explore ----
-----------------------------------------------
function c_message_search_altars_in_temple(text, channel)
  if you.branch() == "Temple" and text:find("explor") then
    crawl.sendkeys({ 6, "altar\r" })
  end
end


-----------------------------
---- Ignore exit portals ----
-----------------------------
local ignore_exit_brances = { "Bailey", "Bazaar", "Ice Cave", "Ossuary", "Sewer", "Trove", "Volcano", "Ziggurat" }
local stop_on_portals = true

function ready_ignore_exits()
  local branch = you.branch()
  if stop_on_portals and util.contains(ignore_exit_brances, branch) then
    stop_on_portals = false
    crawl.setopt("explore_stop -= portals")
  elseif not stop_on_portals and not util.contains(ignore_exit_brances, branch) then
    stop_on_portals = true
    crawl.setopt("explore_stop += portals")
  end
end

}

########features/mute-swaps.rc########

{
-- When an item is moved to its assigned slot, mute the messages for the item that was previously in that slot
-- If we cared what slot the item was in, it'd already be assigned somewhere
-- This mostly matters when reading scroll of ID, where 5-6 lines of inventory items can be confusing

--------------
---- Util ----
--------------
local function cleanup_message(text)
  local tags_removed = {}
  
  local keep_going = true
  while keep_going do
    local opening = text:find("<")
    local closing = text:find(">")    
    
    if opening and closing and opening < closing then
      local new_text = ""
      if opening > 1 then new_text = text:sub(1, opening-1) end
      if closing < #text then new_text = new_text..text:sub(closing+1, #text) end
      text = new_text
    else
      keep_going = false
    end
  end
  
  text = text:gsub("\n", "")
  return text
end

muted_items = {}

-- Must define this separate from ready() if we want to call it from c_message_mute_swaps as well
local function unmute_items()
  for _, v in ipairs(muted_items) do
    crawl.setopt("message_colour -= mute: - "..v)
  end
  muted_items = {}
end
---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function ready_mute_swaps()
  unmute_items()
end

local last_pickup_turn = -1
function c_assign_invletter_mute_swaps(it)
  -- this causes an unmute command on the message
  -- we can't unmute in time from this hook
  if you.turns() == last_pickup_turn then
    crawl.mpr("")
  else
    last_pickup_turn = you.turns()
  end
end

function c_message_mute_swaps(text, channel)
  -- Mute subsequent item re-assignments in a single turn, for everything after the first item.
  -- Multiple slots for the same item will still be shown
  if channel == "plain" then 
    text = cleanup_message(text)
    if text:sub(2,4) == " - " then
      local item = text:sub(5, #text)
      local mute_str = "(?!.*("..item.."))"
      table.insert(muted_items, mute_str)
      crawl.setopt("message_colour ^= mute: - "..mute_str)
      return
    end
  end
  
  unmute_items()
end
}

########features/after-shaft.rc########

{
------------------------------------
---- Stop on stairs after shaft ----
------------------------------------
if not shaft_depth or you.turns() == 0 then
  shaft_depth = 0
  shaft_branch = "NA"
end

function persist_shaft_values()
  local cmd = "shaft_depth = "..shaft_depth..string.char(10) .."shaft_branch = \""..shaft_branch.."\""..string.char(10)
  return cmd
end

if not added_shaft_stairs_hook then
  table.insert(chk_lua_save, persist_shaft_values)
  added_shaft_stairs_hook = true
end


---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_message_after_shaft(text, channel)
  if shaft_depth ~= 0 then return end
  if text:find("fall into a shaft") then
    shaft_depth = you.depth()
    shaft_branch = you.branch()
    crawl.setopt("explore_stop += stairs")
  end
end

function ready_after_shaft()
  if shaft_depth ~= 0 then
    if you.depth() == shaft_depth and you.branch() == shaft_branch then
      crawl.setopt("explore_stop -= stairs")
      shaft_depth = 0
      shaft_branch = "NA"
    end
  end
end

}


####################################################################
######################## Lua Hook Functions ########################
####################################################################
{
----------------------------------
---------- c_message() -----------
----------------------------------
function c_message(text, channel)
  
  if c_message_remind_identify then c_message_remind_identify(text, channel) end
  if c_message_weapon_slots then c_message_weapon_slots(text, channel) end
  if c_message_exclude_dropped then c_message_exclude_dropped(text, channel) end
  --if c_message_safe_consumables then c_message_safe_consumables(text, channel) end
  --if c_message_search_altars_in_temple then c_message_search_altars_in_temple(text, channel) end
  if c_message_fully_recover then c_message_fully_recover(text, channel) end
  --if c_message_mute_swaps then c_message_mute_swaps(text, channel) end
  if c_message_after_shaft then c_message_after_shaft(text, channel) end
  --if c_message_inscribe_dps then c_message_inscribe_dps(text, channel) end

end


-------------------------------------------
---------- c_assign_inv_letter() ----------
-------------------------------------------
function c_assign_invletter(it)
  -- Calls with no return values; just triggering on new item pickup
  if c_assign_invletter_item_alerts then c_assign_invletter_item_alerts(it) end
  if c_assign_invletter_remind_identify then c_assign_invletter_remind_identify(it) end
  if c_assign_invletter_exclude_dropped then c_assign_invletter_exclude_dropped(it) end
  if c_assign_invletter_drop_inferior then c_assign_invletter_drop_inferior(it) end
  if c_assign_invletter_mute_swaps then c_assign_invletter_mute_swaps(it) end
    
  -- Calls with possible return values
  local ret_val = nil
  if c_assign_invletter_weapon_slots then ret_val = c_assign_invletter_weapon_slots(it) end
  if ret_val then return ret_val end
end


---------------------------
---- ch_stop_running() ----
---------------------------
function ch_stop_running(kind)
  if ch_stop_running_full_recovery then ch_stop_running_full_recovery(kind) end
end
}

{
-----------------------------
---- Begin char_defaults ----
-----------------------------

-- See README.md for documentation.

weapon_skills = {"Unarmed Combat", "Short Blades", "Long Blades", "Axes",
                 "Maces & Flails", "Polearms", "Staves"}
ranged_skills = {"Throwing", "Bows", "Crossbows", "Slings"}
other_skills = {"Fighting", "Armour", "Dodging",
                "Shields", "Spellcasting", "Conjurations", "Hexes", "Charms",
                "Summonings", "Necromancy", "Translocations", "Transmutations",
                "Fire Magic", "Ice Magic", "Air Magic", "Earth Magic",
                "Poison Magic", "Invocations", "Evocations","Stealth"}
skill_glyphs = { [1] = "+", [2] = "*" }
chdat = nil
char_combo = you.race() .. you.class()
loaded_attempted = false

-- Wrapper of crawl.mpr() that prints text in white by default.
if not mpr then
  mpr = function (msg, color)
    if not color then
      color = "white"
    end
    crawl.mpr("<" .. color .. ">" .. msg .. "</" .. color .. ">")
  end
end

function skill_message(prefix, skill, skill_type, value)
  local msg = ""
  if prefix then
    msg = prefix .. ";"
  end
  if skill_type then
    msg = msg .. skill_type .. "(" .. skill .. "):" .. value
  else
    msg = msg .. skill .. ":" .. value
  end
  return msg
end

function save_char_defaults(quiet)
  if you.class() == "Wanderer" then
    return
  end
  if not c_persist.char_defaults then
    c_persist.char_defaults = { }
  end
  c_persist.char_defaults[char_combo] = { }
  chdat = c_persist.char_defaults[char_combo]
  local msg = nil
  local have_weapon = false
  for _,sk in ipairs(weapon_skills) do
    if you.train_skill(sk) > 0 then
      chdat["Weapon"] = you.train_skill(sk)
      msg = skill_message(nil, sk, "Weapon",
                          skill_glyphs[chdat["Weapon"]])
      have_weapon = true
      break
    end
  end
  if not have_weapon then
    chdat["Weapon"] = nil
  end
  local have_ranged = false
  for _,sk in ipairs(ranged_skills) do
    if you.train_skill(sk) > 0 then
      chdat["Ranged"] = you.train_skill(sk)
      msg = skill_message(msg, sk, "Ranged",
                          skill_glyphs[chdat["Ranged"]])
      have_ranged = true
      break
    end
  end
  if not have_ranged then
    chdat["Ranged"] = nil
  end
  for _,sk in ipairs(other_skills) do
    if you.train_skill(sk) > 0 then
      chdat[sk] = you.train_skill(sk)
      msg = skill_message(msg, sk, nil, skill_glyphs[chdat[sk]])
    else
      chdat[sk] = nil
    end
  end
  if not quiet then
    mpr("Saved default for " .. char_combo .. ": " .. msg)
  end
end

function have_defaults()
  return  you.class() ~= "Wanderer"
    and c_persist.char_defaults ~= nil
    and c_persist.char_defaults[char_combo] ~= nil
end

function load_char_defaults(quiet)
  if not have_defaults() then
    return
  end
  local msg = nil
  local found_weapon = false
  chdat = c_persist.char_defaults[char_combo]
  for _,sk in ipairs(weapon_skills) do
    if you.base_skill(sk) > 0 and chdat["Weapon"] then
      you.train_skill(sk, chdat["Weapon"])
      msg = skill_message(msg, sk, "Weapon",
                          skill_glyphs[chdat["Weapon"]])
      found_weapon = true
    else
      you.train_skill(sk, 0)
    end
  end
  if chdat["Weapon"] and not found_weapon then
    you.train_skill("Unarmed Combat", chdat["Weapon"])
    msg = skill_message(msg, "Unarmed Combat", "Weapon",
                        skill_glyphs[chdat["Weapon"]])
  end
  local found_ranged = false
  for _,sk in ipairs(ranged_skills) do
    if you.base_skill(sk) > 0 and chdat["Ranged"] then
      you.train_skill(sk, chdat["Ranged"])
      msg = skill_message(msg, sk, "Ranged",
                          skill_glyphs[chdat["Ranged"]])
      found_ranged = true
    else
      you.train_skill(sk, 0)
    end
  end
  if chdat["Ranged"] and not found_ranged then
    you.train_skill("Throwing", chdat["Ranged"])
    msg = skill_message(msg, "Throwing", "Ranged",
                        skill_glyphs[chdat["Ranged"]])
  end
  for _,sk in ipairs(other_skills) do
    if chdat[sk] then
      you.train_skill(sk, chdat[sk])
      msg = skill_message(msg, sk, nil, skill_glyphs[chdat[sk]])
    else
      you.train_skill(sk, 0)
    end
  end
  if not quiet and msg ~= "" then
    mpr("Loaded default for " .. char_combo .. ": " .. msg)
  end
end

function char_defaults(quiet)
  if you.turns() ~= 0 then
    return
  end

  if not load_attempted then
    load_char_defaults(quiet)
    load_attempted = true

    -- Open the skill menu if we don't have settings to load.
    if not have_defaults() then
      crawl.sendkeys("m")
    end
  end
end

---------------------------
---- End char_defaults ----
---------------------------
}

{
function enhanced_explore()
   if you.status():find("contam") or you.status("berserking") or you.status("on berserk cooldown") or you.status("short of breath") or you.status("corroded") or you.status("vulnerable") or you.status("poisoned") then
      crawl.do_commands({"CMD_REST"})
   elseif you.status("slowed") then
      if not (you.strength() <=0 or you.intelligence() <= 0 or you.dexterity() <=0) then
         crawl.do_commands({"CMD_REST"})
      else
        crawl.do_commands({"CMD_EXPLORE"})
      end
   else
      crawl.do_commands({"CMD_EXPLORE"})
   end
end
}
# Ask HilariousDeathArtist to fix things

# To use this you must add have a call to AnnounceDamage() in the ready() function like below:
# This is important if you override this ready() function
# <
#  function ready()
#    AnnounceDamage()
#  end
# >

###############
# Damage Calc #
###############
{
  local previous_hp = 0
  local previous_mp = 0
  local previous_form = ""
  local was_berserk_last_turn = false

  function AnnounceDamage()
    local current_hp, max_hp = you.hp()
    local current_mp, max_mp = you.mp()
    --Things that increase hp/mp temporarily really mess with this
    local current_form = you.transform()
    local you_are_berserk = you.berserk()
    local max_hp_increased = false
    local max_hp_decreased = false

    if (current_form ~= previous_form) then
      if (previous_form:find("dragon") or
          previous_form:find("statue") or
          previous_form:find("tree") or
          previous_form:find("ice")) then
        max_hp_decreased = true
      elseif (current_form:find("dragon") or
          current_form:find("statue") or
          current_form:find("tree") or
          current_form:find("ice")) then
        max_hp_increased = true
      end
    end
    if (was_berserk_last_turn and not you_are_berserk) then
      max_hp_decreased = true
    elseif (you_are_berserk and not was_berserk_last_turn) then
      max_hp_increased = true
    end

    --crawl.mpr(string.format("previous_form is: %s", previous_form))
    --crawl.mpr(string.format("current_form is: %s", current_form))
    --crawl.mpr(string.format("max_hp_increased is: %s", max_hp_increased and "True" or "False"))
    --crawl.mpr(string.format("max_hp_decreased is: %s", max_hp_decreased and "True" or "False"))

    --crawl.mpr(string:format("you_are_berserk is: %s", you_are_berserk and "True" or "False"))
    --crawl.mpr(string:format("was_berserk_last_turn is: %s", was_berserk_last_turn and "True" or "False"))


    --Skips message on initializing game
    if previous_hp > 0 then
      local hp_difference = previous_hp - current_hp
      local mp_difference = previous_mp - current_mp

      if max_hp_increased or max_hp_decreased then
        if max_hp_increased then
          crawl.mpr("<green>You now have " .. current_hp .. "/" .. max_hp .. " hp.</green>")
        else
          crawl.mpr("<yellow>You now have " .. current_hp .. "/" .. max_hp .. " hp.</yellow>")
        end
      else
        --On losing health
        if (current_hp < previous_hp) then
          if current_hp <= (max_hp * 0.30) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><lightred> and have " .. current_hp .. "/" .. max_hp .. " hp.</lightred>")
          elseif current_hp <= (max_hp * 0.50) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage, and have " .. current_hp .. "/" .. max_hp .. " hp.</red>")
          elseif current_hp <= (max_hp *  0.70) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><yellow> and have " .. current_hp .. "/" .. max_hp .. " hp.</yellow>")
          elseif current_hp <= (max_hp * 0.90) then
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><lightgrey> and have " .. current_hp .. "/" .. max_hp .. " hp.</lightgrey>")
          else
            crawl.mpr("<red>You take " .. hp_difference .. " damage,</red><green> and have " .. current_hp .. "/" .. max_hp .. " hp.</green>")
          end
          if hp_difference > (max_hp * 0.20) then
            crawl.mpr("<lightred>MASSIVE DAMAGE!!</lightred>")
          end
        end

        --On gaining more than 1 health
        if (current_hp > previous_hp) then
          --Removes the negative sign
          local health_inturn = (0 - hp_difference)
          if (health_inturn > 1) and not (current_hp == max_hp) then
            if current_hp <= (max_hp * 0.30) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><lightred> and now have " .. current_hp .. "/" .. max_hp .. " hp.</lightred>")
            elseif current_hp <= (max_hp * 0.50) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><red> and now have " .. current_hp .. "/" .. max_hp .. " hp.</red>")
            elseif current_hp <= (max_hp *  0.70) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><yellow> and now have " .. current_hp .. "/" .. max_hp .. " hp.</yellow>")
            elseif current_hp <= (max_hp * 0.90) then
              crawl.mpr("<green>You regained " .. health_inturn .. " hp,</green><lightgrey> and now have " .. current_hp .. "/" .. max_hp .. " hp.</lightgrey>")
            else
              crawl.mpr("<green>You regained " .. health_inturn .. " hp, and now have " .. current_hp .. "/" .. max_hp .. " hp.</green>")
            end
          end
          if (current_hp == max_hp) then
            crawl.mpr("<green>Health restored: " .. current_hp .. "</green>")
          end
        end

        --On gaining more than 1 magic
        if (current_mp > previous_mp) then
          --Removes the negative sign
          local mp_inturn = (0 - mp_difference)
          if (mp_inturn > 1) and not (current_mp == max_mp) then
            if current_mp < (max_mp * 0.25) then
              crawl.mpr("<lightcyan>You regained " .. mp_inturn .. " mp,</lightcyan><red> and now have " .. current_mp .. "/" .. max_mp .. " mp.</red>")
            elseif current_mp < (max_mp * 0.50) then
              crawl.mpr("<lightcyan>You regained " .. mp_inturn .. " mp,</lightcyan><yellow> and now have " .. current_mp .. "/" .. max_mp .. " mp.</yellow>")
            else
              crawl.mpr("<lightcyan>You regained " .. mp_inturn .. " mp,</lightcyan><green> and now have " .. current_mp .. "/" .. max_mp .. " mp.</green>")
            end
          end
          if (current_mp == max_mp) then
            crawl.mpr("<lightcyan>MP restored: " .. current_mp .. "</lightcyan>")
          end
        end

        --On losing magic
        if current_mp < previous_mp then
          if current_mp <= (max_mp / 5) then
            crawl.mpr("<lightcyan>You now have </lightcyan><red>" .. current_mp .. "/" ..max_mp .." mp.</red>")
          elseif current_mp <= (max_mp / 2) then
            crawl.mpr("<lightcyan>You now have </lightcyan><yellow>" .. current_mp .. "/" ..max_mp .." mp.</yellow>")
          else
            crawl.mpr("<lightcyan>You now have </lightcyan><green>" .. current_mp .. "/" ..max_mp .." mp.</green>")
          end
        end
      end
    end

    --Set previous hp/mp and form at end of turn
    previous_hp = current_hp
    previous_mp = current_mp
    previous_form = current_form
    was_berserk_last_turn = you_are_berserk
  end
}



# The ready() function  is needed for code that has to process each turn or UI
# action.
{
function ready()

  if char_defaults then char_defaults() end

  if AnnounceDamage then AnnounceDamage() end


  if ready_force_mores then ready_force_mores() end
  if ready_dynamic_options then ready_dynamic_options() end
  if ready_weapon_slots then ready_weapon_slots() end
  --if ready_safe_consumables then ready_safe_consumables() end
  -- Cant use because of inscription
  if ready_mute_swaps then ready_mute_swaps() end
  if ready_ignore_altars then ready_ignore_altars() end
  if ready_ignore_exits then ready_ignore_exits() end
  if ready_after_shaft then ready_after_shaft() end
  if ready_fully_recover then ready_fully_recover() end

  
  if not next_skill_level then
    next_skill_level = 3
  end
  
  if you.xl() >= next_skill_level then
    next_skill_level = ((you.xl()/3)*3)+3
    crawl.sendkeys("m")
  end



end
}

#############
### Debug ###
#############

fsim_rounds = 10000